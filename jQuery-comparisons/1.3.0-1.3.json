[{"id":"94971f4ab0a6a591dfb7de526efb1909600cbc9e","instances":[{"path":"./jquery-data/1.3.0/src/event.js","lines":[93,680],"code":"\t// Detach an event or set of events from an element\n\tremove: function(elem, types, handler) {\n\t\t// don't do events on text and comment nodes\n\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\treturn;\n\n\t\tvar events = jQuery.data(elem, \"events\"), ret, index;\n\n\t\tif ( events ) {\n\t\t\t// Unbind all events for the element\n\t\t\tif ( types === undefined || (typeof types === \"string\" && types.charAt(0) == \".\") )\n\t\t\t\tfor ( var type in events )\n\t\t\t\t\tthis.remove( elem, type + (types || \"\") );\n\t\t\telse {\n\t\t\t\t// types is actually an event object here\n\t\t\t\tif ( types.type ) {\n\t\t\t\t\thandler = types.handler;\n\t\t\t\t\ttypes = types.type;\n\t\t\t\t}\n\n\t\t\t\t// Handle multiple events seperated by a space\n\t\t\t\t// jQuery(...).unbind(\"mouseover mouseout\", fn);\n\t\t\t\tjQuery.each(types.split(/\\s+/), function(index, type){\n\t\t\t\t\t// Namespaced event handlers\n\t\t\t\t\tvar namespaces = type.split(\".\");\n\t\t\t\t\ttype = namespaces.shift();\n\t\t\t\t\tvar namespace = RegExp(\"(^|\\\\.)\" + namespaces.slice().sort().join(\".*\\\\.\") + \"(\\\\.|$)\");\n\n\t\t\t\t\tif ( events[type] ) {\n\t\t\t\t\t\t// remove the given handler for the given type\n\t\t\t\t\t\tif ( handler )\n\t\t\t\t\t\t\tdelete events[type][handler.guid];\n\n\t\t\t\t\t\t// remove all handlers for the given type\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfor ( var handle in events[type] )\n\t\t\t\t\t\t\t\t// Handle the removal of namespaced events\n\t\t\t\t\t\t\t\tif ( namespace.test(events[type][handle].type) )\n\t\t\t\t\t\t\t\t\tdelete events[type][handle];\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tif ( jQuery.event.specialAll[type] )\n\t\t\t\t\t\t\tjQuery.event.specialAll[type].teardown.call(elem, namespaces);\n\n\t\t\t\t\t\t// remove generic event handler if no more handlers exist\n\t\t\t\t\t\tfor ( ret in events[type] ) break;\n\t\t\t\t\t\tif ( !ret ) {\n\t\t\t\t\t\t\tif ( !jQuery.event.special[type] || jQuery.event.special[type].teardown.call(elem, namespaces) === false ) {\n\t\t\t\t\t\t\t\tif (elem.removeEventListener)\n\t\t\t\t\t\t\t\t\telem.removeEventListener(type, jQuery.data(elem, \"handle\"), false);\n\t\t\t\t\t\t\t\telse if (elem.detachEvent)\n\t\t\t\t\t\t\t\t\telem.detachEvent(\"on\" + type, jQuery.data(elem, \"handle\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tret = null;\n\t\t\t\t\t\t\tdelete events[type];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Remove the expando if it's no longer used\n\t\t\tfor ( ret in events ) break;\n\t\t\tif ( !ret ) {\n\t\t\t\tvar handle = jQuery.data( elem, \"handle\" );\n\t\t\t\tif ( handle ) handle.elem = null;\n\t\t\t\tjQuery.removeData( elem, \"events\" );\n\t\t\t\tjQuery.removeData( elem, \"handle\" );\n\t\t\t}\n\t\t}\n\t},\n\n\t// bubbling is internal\n\ttrigger: function( event, data, elem, bubbling ) {\n\t\t// Event object or event type\n\t\tvar type = event.type || event;\n\n\t\tif( !bubbling ){\n\t\t\tevent = typeof event === \"object\" ?\n\t\t\t\t// jQuery.Event object\n\t\t\t\tevent[expando] ? event :\n\t\t\t\t// Object literal\n\t\t\t\tjQuery.extend( jQuery.Event(type), event ) :\n\t\t\t\t// Just the event type (string)\n\t\t\t\tjQuery.Event(type);\n\n\t\t\tif ( type.indexOf(\"!\") >= 0 ) {\n\t\t\t\tevent.type = type = type.slice(0, -1);\n\t\t\t\tevent.exclusive = true;\n\t\t\t}\n\n\t\t\t// Handle a global trigger\n\t\t\tif ( !elem ) {\n\t\t\t\t// Don't bubble custom events when global (to avoid too much overhead)\n\t\t\t\tevent.stopPropagation();\n\t\t\t\t// Only trigger if we've ever bound an event for it\n\t\t\t\tif ( this.global[type] )\n\t\t\t\t\tjQuery.each( jQuery.cache, function(){\n\t\t\t\t\t\tif ( this.events && this.events[type] )\n\t\t\t\t\t\t\tjQuery.event.trigger( event, data, this.handle.elem );\n\t\t\t\t\t});\n\t\t\t}"},{"path":"./jquery-data/1.3/src/event.js","lines":[93,680],"code":"\t// Detach an event or set of events from an element\n\tremove: function(elem, types, handler) {\n\t\t// don't do events on text and comment nodes\n\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\treturn;\n\n\t\tvar events = jQuery.data(elem, \"events\"), ret, index;\n\n\t\tif ( events ) {\n\t\t\t// Unbind all events for the element\n\t\t\tif ( types === undefined || (typeof types === \"string\" && types.charAt(0) == \".\") )\n\t\t\t\tfor ( var type in events )\n\t\t\t\t\tthis.remove( elem, type + (types || \"\") );\n\t\t\telse {\n\t\t\t\t// types is actually an event object here\n\t\t\t\tif ( types.type ) {\n\t\t\t\t\thandler = types.handler;\n\t\t\t\t\ttypes = types.type;\n\t\t\t\t}\n\n\t\t\t\t// Handle multiple events seperated by a space\n\t\t\t\t// jQuery(...).unbind(\"mouseover mouseout\", fn);\n\t\t\t\tjQuery.each(types.split(/\\s+/), function(index, type){\n\t\t\t\t\t// Namespaced event handlers\n\t\t\t\t\tvar namespaces = type.split(\".\");\n\t\t\t\t\ttype = namespaces.shift();\n\t\t\t\t\tvar namespace = RegExp(\"(^|\\\\.)\" + namespaces.slice().sort().join(\".*\\\\.\") + \"(\\\\.|$)\");\n\n\t\t\t\t\tif ( events[type] ) {\n\t\t\t\t\t\t// remove the given handler for the given type\n\t\t\t\t\t\tif ( handler )\n\t\t\t\t\t\t\tdelete events[type][handler.guid];\n\n\t\t\t\t\t\t// remove all handlers for the given type\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfor ( var handle in events[type] )\n\t\t\t\t\t\t\t\t// Handle the removal of namespaced events\n\t\t\t\t\t\t\t\tif ( namespace.test(events[type][handle].type) )\n\t\t\t\t\t\t\t\t\tdelete events[type][handle];\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tif ( jQuery.event.specialAll[type] )\n\t\t\t\t\t\t\tjQuery.event.specialAll[type].teardown.call(elem, namespaces);\n\n\t\t\t\t\t\t// remove generic event handler if no more handlers exist\n\t\t\t\t\t\tfor ( ret in events[type] ) break;\n\t\t\t\t\t\tif ( !ret ) {\n\t\t\t\t\t\t\tif ( !jQuery.event.special[type] || jQuery.event.special[type].teardown.call(elem, namespaces) === false ) {\n\t\t\t\t\t\t\t\tif (elem.removeEventListener)\n\t\t\t\t\t\t\t\t\telem.removeEventListener(type, jQuery.data(elem, \"handle\"), false);\n\t\t\t\t\t\t\t\telse if (elem.detachEvent)\n\t\t\t\t\t\t\t\t\telem.detachEvent(\"on\" + type, jQuery.data(elem, \"handle\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tret = null;\n\t\t\t\t\t\t\tdelete events[type];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Remove the expando if it's no longer used\n\t\t\tfor ( ret in events ) break;\n\t\t\tif ( !ret ) {\n\t\t\t\tvar handle = jQuery.data( elem, \"handle\" );\n\t\t\t\tif ( handle ) handle.elem = null;\n\t\t\t\tjQuery.removeData( elem, \"events\" );\n\t\t\t\tjQuery.removeData( elem, \"handle\" );\n\t\t\t}\n\t\t}\n\t},\n\n\t// bubbling is internal\n\ttrigger: function( event, data, elem, bubbling ) {\n\t\t// Event object or event type\n\t\tvar type = event.type || event;\n\n\t\tif( !bubbling ){\n\t\t\tevent = typeof event === \"object\" ?\n\t\t\t\t// jQuery.Event object\n\t\t\t\tevent[expando] ? event :\n\t\t\t\t// Object literal\n\t\t\t\tjQuery.extend( jQuery.Event(type), event ) :\n\t\t\t\t// Just the event type (string)\n\t\t\t\tjQuery.Event(type);\n\n\t\t\tif ( type.indexOf(\"!\") >= 0 ) {\n\t\t\t\tevent.type = type = type.slice(0, -1);\n\t\t\t\tevent.exclusive = true;\n\t\t\t}\n\n\t\t\t// Handle a global trigger\n\t\t\tif ( !elem ) {\n\t\t\t\t// Don't bubble custom events when global (to avoid too much overhead)\n\t\t\t\tevent.stopPropagation();\n\t\t\t\t// Only trigger if we've ever bound an event for it\n\t\t\t\tif ( this.global[type] )\n\t\t\t\t\tjQuery.each( jQuery.cache, function(){\n\t\t\t\t\t\tif ( this.events && this.events[type] )\n\t\t\t\t\t\t\tjQuery.event.trigger( event, data, this.handle.elem );\n\t\t\t\t\t});\n\t\t\t}"}]},
{"id":"94971f4ab0a6a591dfb7de526efb1909600cbc9e","instances":[{"path":"./jquery-data/1.3.0/src/event.js","lines":[93,680],"code":"\t// Detach an event or set of events from an element\n\tremove: function(elem, types, handler) {\n\t\t// don't do events on text and comment nodes\n\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\treturn;\n\n\t\tvar events = jQuery.data(elem, \"events\"), ret, index;\n\n\t\tif ( events ) {\n\t\t\t// Unbind all events for the element\n\t\t\tif ( types === undefined || (typeof types === \"string\" && types.charAt(0) == \".\") )\n\t\t\t\tfor ( var type in events )\n\t\t\t\t\tthis.remove( elem, type + (types || \"\") );\n\t\t\telse {\n\t\t\t\t// types is actually an event object here\n\t\t\t\tif ( types.type ) {\n\t\t\t\t\thandler = types.handler;\n\t\t\t\t\ttypes = types.type;\n\t\t\t\t}\n\n\t\t\t\t// Handle multiple events seperated by a space\n\t\t\t\t// jQuery(...).unbind(\"mouseover mouseout\", fn);\n\t\t\t\tjQuery.each(types.split(/\\s+/), function(index, type){\n\t\t\t\t\t// Namespaced event handlers\n\t\t\t\t\tvar namespaces = type.split(\".\");\n\t\t\t\t\ttype = namespaces.shift();\n\t\t\t\t\tvar namespace = RegExp(\"(^|\\\\.)\" + namespaces.slice().sort().join(\".*\\\\.\") + \"(\\\\.|$)\");\n\n\t\t\t\t\tif ( events[type] ) {\n\t\t\t\t\t\t// remove the given handler for the given type\n\t\t\t\t\t\tif ( handler )\n\t\t\t\t\t\t\tdelete events[type][handler.guid];\n\n\t\t\t\t\t\t// remove all handlers for the given type\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfor ( var handle in events[type] )\n\t\t\t\t\t\t\t\t// Handle the removal of namespaced events\n\t\t\t\t\t\t\t\tif ( namespace.test(events[type][handle].type) )\n\t\t\t\t\t\t\t\t\tdelete events[type][handle];\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tif ( jQuery.event.specialAll[type] )\n\t\t\t\t\t\t\tjQuery.event.specialAll[type].teardown.call(elem, namespaces);\n\n\t\t\t\t\t\t// remove generic event handler if no more handlers exist\n\t\t\t\t\t\tfor ( ret in events[type] ) break;\n\t\t\t\t\t\tif ( !ret ) {\n\t\t\t\t\t\t\tif ( !jQuery.event.special[type] || jQuery.event.special[type].teardown.call(elem, namespaces) === false ) {\n\t\t\t\t\t\t\t\tif (elem.removeEventListener)\n\t\t\t\t\t\t\t\t\telem.removeEventListener(type, jQuery.data(elem, \"handle\"), false);\n\t\t\t\t\t\t\t\telse if (elem.detachEvent)\n\t\t\t\t\t\t\t\t\telem.detachEvent(\"on\" + type, jQuery.data(elem, \"handle\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tret = null;\n\t\t\t\t\t\t\tdelete events[type];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Remove the expando if it's no longer used\n\t\t\tfor ( ret in events ) break;\n\t\t\tif ( !ret ) {\n\t\t\t\tvar handle = jQuery.data( elem, \"handle\" );\n\t\t\t\tif ( handle ) handle.elem = null;\n\t\t\t\tjQuery.removeData( elem, \"events\" );\n\t\t\t\tjQuery.removeData( elem, \"handle\" );\n\t\t\t}\n\t\t}\n\t},\n\n\t// bubbling is internal\n\ttrigger: function( event, data, elem, bubbling ) {\n\t\t// Event object or event type\n\t\tvar type = event.type || event;\n\n\t\tif( !bubbling ){\n\t\t\tevent = typeof event === \"object\" ?\n\t\t\t\t// jQuery.Event object\n\t\t\t\tevent[expando] ? event :\n\t\t\t\t// Object literal\n\t\t\t\tjQuery.extend( jQuery.Event(type), event ) :\n\t\t\t\t// Just the event type (string)\n\t\t\t\tjQuery.Event(type);\n\n\t\t\tif ( type.indexOf(\"!\") >= 0 ) {\n\t\t\t\tevent.type = type = type.slice(0, -1);\n\t\t\t\tevent.exclusive = true;\n\t\t\t}\n\n\t\t\t// Handle a global trigger\n\t\t\tif ( !elem ) {\n\t\t\t\t// Don't bubble custom events when global (to avoid too much overhead)\n\t\t\t\tevent.stopPropagation();\n\t\t\t\t// Only trigger if we've ever bound an event for it\n\t\t\t\tif ( this.global[type] )\n\t\t\t\t\tjQuery.each( jQuery.cache, function(){\n\t\t\t\t\t\tif ( this.events && this.events[type] )\n\t\t\t\t\t\t\tjQuery.event.trigger( event, data, this.handle.elem );\n\t\t\t\t\t});\n\t\t\t}"},{"path":"./jquery-data/1.3/src/event.js","lines":[93,680],"code":"\t// Detach an event or set of events from an element\n\tremove: function(elem, types, handler) {\n\t\t// don't do events on text and comment nodes\n\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\treturn;\n\n\t\tvar events = jQuery.data(elem, \"events\"), ret, index;\n\n\t\tif ( events ) {\n\t\t\t// Unbind all events for the element\n\t\t\tif ( types === undefined || (typeof types === \"string\" && types.charAt(0) == \".\") )\n\t\t\t\tfor ( var type in events )\n\t\t\t\t\tthis.remove( elem, type + (types || \"\") );\n\t\t\telse {\n\t\t\t\t// types is actually an event object here\n\t\t\t\tif ( types.type ) {\n\t\t\t\t\thandler = types.handler;\n\t\t\t\t\ttypes = types.type;\n\t\t\t\t}\n\n\t\t\t\t// Handle multiple events seperated by a space\n\t\t\t\t// jQuery(...).unbind(\"mouseover mouseout\", fn);\n\t\t\t\tjQuery.each(types.split(/\\s+/), function(index, type){\n\t\t\t\t\t// Namespaced event handlers\n\t\t\t\t\tvar namespaces = type.split(\".\");\n\t\t\t\t\ttype = namespaces.shift();\n\t\t\t\t\tvar namespace = RegExp(\"(^|\\\\.)\" + namespaces.slice().sort().join(\".*\\\\.\") + \"(\\\\.|$)\");\n\n\t\t\t\t\tif ( events[type] ) {\n\t\t\t\t\t\t// remove the given handler for the given type\n\t\t\t\t\t\tif ( handler )\n\t\t\t\t\t\t\tdelete events[type][handler.guid];\n\n\t\t\t\t\t\t// remove all handlers for the given type\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfor ( var handle in events[type] )\n\t\t\t\t\t\t\t\t// Handle the removal of namespaced events\n\t\t\t\t\t\t\t\tif ( namespace.test(events[type][handle].type) )\n\t\t\t\t\t\t\t\t\tdelete events[type][handle];\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tif ( jQuery.event.specialAll[type] )\n\t\t\t\t\t\t\tjQuery.event.specialAll[type].teardown.call(elem, namespaces);\n\n\t\t\t\t\t\t// remove generic event handler if no more handlers exist\n\t\t\t\t\t\tfor ( ret in events[type] ) break;\n\t\t\t\t\t\tif ( !ret ) {\n\t\t\t\t\t\t\tif ( !jQuery.event.special[type] || jQuery.event.special[type].teardown.call(elem, namespaces) === false ) {\n\t\t\t\t\t\t\t\tif (elem.removeEventListener)\n\t\t\t\t\t\t\t\t\telem.removeEventListener(type, jQuery.data(elem, \"handle\"), false);\n\t\t\t\t\t\t\t\telse if (elem.detachEvent)\n\t\t\t\t\t\t\t\t\telem.detachEvent(\"on\" + type, jQuery.data(elem, \"handle\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tret = null;\n\t\t\t\t\t\t\tdelete events[type];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Remove the expando if it's no longer used\n\t\t\tfor ( ret in events ) break;\n\t\t\tif ( !ret ) {\n\t\t\t\tvar handle = jQuery.data( elem, \"handle\" );\n\t\t\t\tif ( handle ) handle.elem = null;\n\t\t\t\tjQuery.removeData( elem, \"events\" );\n\t\t\t\tjQuery.removeData( elem, \"handle\" );\n\t\t\t}\n\t\t}\n\t},\n\n\t// bubbling is internal\n\ttrigger: function( event, data, elem, bubbling ) {\n\t\t// Event object or event type\n\t\tvar type = event.type || event;\n\n\t\tif( !bubbling ){\n\t\t\tevent = typeof event === \"object\" ?\n\t\t\t\t// jQuery.Event object\n\t\t\t\tevent[expando] ? event :\n\t\t\t\t// Object literal\n\t\t\t\tjQuery.extend( jQuery.Event(type), event ) :\n\t\t\t\t// Just the event type (string)\n\t\t\t\tjQuery.Event(type);\n\n\t\t\tif ( type.indexOf(\"!\") >= 0 ) {\n\t\t\t\tevent.type = type = type.slice(0, -1);\n\t\t\t\tevent.exclusive = true;\n\t\t\t}\n\n\t\t\t// Handle a global trigger\n\t\t\tif ( !elem ) {\n\t\t\t\t// Don't bubble custom events when global (to avoid too much overhead)\n\t\t\t\tevent.stopPropagation();\n\t\t\t\t// Only trigger if we've ever bound an event for it\n\t\t\t\tif ( this.global[type] )\n\t\t\t\t\tjQuery.each( jQuery.cache, function(){\n\t\t\t\t\t\tif ( this.events && this.events[type] )\n\t\t\t\t\t\t\tjQuery.event.trigger( event, data, this.handle.elem );\n\t\t\t\t\t});\n\t\t\t}"}]},
{"id":"316a21f8c397609feda3d8f40388265c57f34859","instances":[{"path":"./jquery-data/1.3.0/src/fx.js","lines":[1,395],"code":"var elemdisplay = {},\n\tfxAttrs = [\n\t\t// height animations\n\t\t[ \"height\", \"marginTop\", \"marginBottom\", \"paddingTop\", \"paddingBottom\" ],\n\t\t// width animations\n\t\t[ \"width\", \"marginLeft\", \"marginRight\", \"paddingLeft\", \"paddingRight\" ],\n\t\t// opacity animations\n\t\t[ \"opacity\" ]\n\t];\n\nfunction genFx( type, num ){\n\tvar obj = {};\n\tjQuery.each( fxAttrs.concat.apply([], fxAttrs.slice(0,num)), function(){\n\t\tobj[ this ] = type;\n\t});\n\treturn obj;\n}\n\njQuery.fn.extend({\n\tshow: function(speed,callback){\n\t\tif ( speed ) {\n\t\t\treturn this.animate( genFx(\"show\", 3), speed, callback);\n\t\t} else {\n\t\t\tfor ( var i = 0, l = this.length; i < l; i++ ){\n\t\t\t\tvar old = jQuery.data(this[i], \"olddisplay\");\n\t\t\t\t\n\t\t\t\tthis[i].style.display = old || \"\";\n\t\t\t\t\n\t\t\t\tif ( jQuery.css(this[i], \"display\") === \"none\" ) {\n\t\t\t\t\tvar tagName = this[i].tagName, display;\n\t\t\t\t\t\n\t\t\t\t\tif ( elemdisplay[ tagName ] ) {\n\t\t\t\t\t\tdisplay = elemdisplay[ tagName ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar elem = jQuery(\"<\" + tagName + \" />\").appendTo(\"body\");\n\t\t\t\t\t\t\n\t\t\t\t\t\tdisplay = elem.css(\"display\");\n\t\t\t\t\t\tif ( display === \"none\" )\n\t\t\t\t\t\t\tdisplay = \"block\";\n\t\t\t\t\t\t\n\t\t\t\t\t\telem.remove();\n\t\t\t\t\t\t\n\t\t\t\t\t\telemdisplay[ tagName ] = display;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis[i].style.display = jQuery.data(this[i], \"olddisplay\", display);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\t\t}\n\t},\n\n\thide: function(speed,callback){\n\t\tif ( speed ) {\n\t\t\treturn this.animate( genFx(\"hide\", 3), speed, callback);\n\t\t} else {\n\t\t\tfor ( var i = 0, l = this.length; i < l; i++ ){\n\t\t\t\tvar old = jQuery.data(this[i], \"olddisplay\");\n\t\t\t\tif ( !old && old !== \"none\" )\n\t\t\t\t\tjQuery.data(this[i], \"olddisplay\", jQuery.css(this[i], \"display\"));\n\t\t\t\tthis[i].style.display = \"none\";\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t},\n\n\t// Save the old toggle function\n\t_toggle: jQuery.fn.toggle,\n\n\ttoggle: function( fn, fn2 ){\n\t\tvar bool = typeof fn === \"boolean\";\n\n\t\treturn jQuery.isFunction(fn) && jQuery.isFunction(fn2) ?\n\t\t\tthis._toggle.apply( this, arguments ) :\n\t\t\tfn == null || bool ?\n\t\t\t\tthis.each(function(){\n\t\t\t\t\tvar state = bool ? fn : jQuery(this).is(\":hidden\");\n\t\t\t\t\tjQuery(this)[ state ? \"show\" : \"hide\" ]();\n\t\t\t\t}) :\n\t\t\t\tthis.animate(genFx(\"toggle\", 3), fn, fn2);\n\t},\n\n\tfadeTo: function(speed,to,callback){\n\t\treturn this.animate({opacity: to}, speed, callback);\n\t},\n\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar optall = jQuery.speed(speed, easing, callback);\n\n\t\treturn this[ optall.queue === false ? \"each\" : \"queue\" ](function(){\n\t\t\n\t\t\tvar opt = jQuery.extend({}, optall), p,\n\t\t\t\thidden = this.nodeType == 1 && jQuery(this).is(\":hidden\"),\n\t\t\t\tself = this;\n\t\n\t\t\tfor ( p in prop ) {\n\t\t\t\tif ( prop[p] == \"hide\" && hidden || prop[p] == \"show\" && !hidden )\n\t\t\t\t\treturn opt.complete.call(this);\n"},{"path":"./jquery-data/1.3/src/fx.js","lines":[1,395],"code":"var elemdisplay = {},\n\tfxAttrs = [\n\t\t// height animations\n\t\t[ \"height\", \"marginTop\", \"marginBottom\", \"paddingTop\", \"paddingBottom\" ],\n\t\t// width animations\n\t\t[ \"width\", \"marginLeft\", \"marginRight\", \"paddingLeft\", \"paddingRight\" ],\n\t\t// opacity animations\n\t\t[ \"opacity\" ]\n\t];\n\nfunction genFx( type, num ){\n\tvar obj = {};\n\tjQuery.each( fxAttrs.concat.apply([], fxAttrs.slice(0,num)), function(){\n\t\tobj[ this ] = type;\n\t});\n\treturn obj;\n}\n\njQuery.fn.extend({\n\tshow: function(speed,callback){\n\t\tif ( speed ) {\n\t\t\treturn this.animate( genFx(\"show\", 3), speed, callback);\n\t\t} else {\n\t\t\tfor ( var i = 0, l = this.length; i < l; i++ ){\n\t\t\t\tvar old = jQuery.data(this[i], \"olddisplay\");\n\t\t\t\t\n\t\t\t\tthis[i].style.display = old || \"\";\n\t\t\t\t\n\t\t\t\tif ( jQuery.css(this[i], \"display\") === \"none\" ) {\n\t\t\t\t\tvar tagName = this[i].tagName, display;\n\t\t\t\t\t\n\t\t\t\t\tif ( elemdisplay[ tagName ] ) {\n\t\t\t\t\t\tdisplay = elemdisplay[ tagName ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar elem = jQuery(\"<\" + tagName + \" />\").appendTo(\"body\");\n\t\t\t\t\t\t\n\t\t\t\t\t\tdisplay = elem.css(\"display\");\n\t\t\t\t\t\tif ( display === \"none\" )\n\t\t\t\t\t\t\tdisplay = \"block\";\n\t\t\t\t\t\t\n\t\t\t\t\t\telem.remove();\n\t\t\t\t\t\t\n\t\t\t\t\t\telemdisplay[ tagName ] = display;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis[i].style.display = jQuery.data(this[i], \"olddisplay\", display);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\t\t}\n\t},\n\n\thide: function(speed,callback){\n\t\tif ( speed ) {\n\t\t\treturn this.animate( genFx(\"hide\", 3), speed, callback);\n\t\t} else {\n\t\t\tfor ( var i = 0, l = this.length; i < l; i++ ){\n\t\t\t\tvar old = jQuery.data(this[i], \"olddisplay\");\n\t\t\t\tif ( !old && old !== \"none\" )\n\t\t\t\t\tjQuery.data(this[i], \"olddisplay\", jQuery.css(this[i], \"display\"));\n\t\t\t\tthis[i].style.display = \"none\";\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t},\n\n\t// Save the old toggle function\n\t_toggle: jQuery.fn.toggle,\n\n\ttoggle: function( fn, fn2 ){\n\t\tvar bool = typeof fn === \"boolean\";\n\n\t\treturn jQuery.isFunction(fn) && jQuery.isFunction(fn2) ?\n\t\t\tthis._toggle.apply( this, arguments ) :\n\t\t\tfn == null || bool ?\n\t\t\t\tthis.each(function(){\n\t\t\t\t\tvar state = bool ? fn : jQuery(this).is(\":hidden\");\n\t\t\t\t\tjQuery(this)[ state ? \"show\" : \"hide\" ]();\n\t\t\t\t}) :\n\t\t\t\tthis.animate(genFx(\"toggle\", 3), fn, fn2);\n\t},\n\n\tfadeTo: function(speed,to,callback){\n\t\treturn this.animate({opacity: to}, speed, callback);\n\t},\n\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar optall = jQuery.speed(speed, easing, callback);\n\n\t\treturn this[ optall.queue === false ? \"each\" : \"queue\" ](function(){\n\t\t\n\t\t\tvar opt = jQuery.extend({}, optall), p,\n\t\t\t\thidden = this.nodeType == 1 && jQuery(this).is(\":hidden\"),\n\t\t\t\tself = this;\n\t\n\t\t\tfor ( p in prop ) {\n\t\t\t\tif ( prop[p] == \"hide\" && hidden || prop[p] == \"show\" && !hidden )\n\t\t\t\t\treturn opt.complete.call(this);\n"}]},
{"id":"316a21f8c397609feda3d8f40388265c57f34859","instances":[{"path":"./jquery-data/1.3.0/src/fx.js","lines":[1,395],"code":"var elemdisplay = {},\n\tfxAttrs = [\n\t\t// height animations\n\t\t[ \"height\", \"marginTop\", \"marginBottom\", \"paddingTop\", \"paddingBottom\" ],\n\t\t// width animations\n\t\t[ \"width\", \"marginLeft\", \"marginRight\", \"paddingLeft\", \"paddingRight\" ],\n\t\t// opacity animations\n\t\t[ \"opacity\" ]\n\t];\n\nfunction genFx( type, num ){\n\tvar obj = {};\n\tjQuery.each( fxAttrs.concat.apply([], fxAttrs.slice(0,num)), function(){\n\t\tobj[ this ] = type;\n\t});\n\treturn obj;\n}\n\njQuery.fn.extend({\n\tshow: function(speed,callback){\n\t\tif ( speed ) {\n\t\t\treturn this.animate( genFx(\"show\", 3), speed, callback);\n\t\t} else {\n\t\t\tfor ( var i = 0, l = this.length; i < l; i++ ){\n\t\t\t\tvar old = jQuery.data(this[i], \"olddisplay\");\n\t\t\t\t\n\t\t\t\tthis[i].style.display = old || \"\";\n\t\t\t\t\n\t\t\t\tif ( jQuery.css(this[i], \"display\") === \"none\" ) {\n\t\t\t\t\tvar tagName = this[i].tagName, display;\n\t\t\t\t\t\n\t\t\t\t\tif ( elemdisplay[ tagName ] ) {\n\t\t\t\t\t\tdisplay = elemdisplay[ tagName ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar elem = jQuery(\"<\" + tagName + \" />\").appendTo(\"body\");\n\t\t\t\t\t\t\n\t\t\t\t\t\tdisplay = elem.css(\"display\");\n\t\t\t\t\t\tif ( display === \"none\" )\n\t\t\t\t\t\t\tdisplay = \"block\";\n\t\t\t\t\t\t\n\t\t\t\t\t\telem.remove();\n\t\t\t\t\t\t\n\t\t\t\t\t\telemdisplay[ tagName ] = display;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis[i].style.display = jQuery.data(this[i], \"olddisplay\", display);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\t\t}\n\t},\n\n\thide: function(speed,callback){\n\t\tif ( speed ) {\n\t\t\treturn this.animate( genFx(\"hide\", 3), speed, callback);\n\t\t} else {\n\t\t\tfor ( var i = 0, l = this.length; i < l; i++ ){\n\t\t\t\tvar old = jQuery.data(this[i], \"olddisplay\");\n\t\t\t\tif ( !old && old !== \"none\" )\n\t\t\t\t\tjQuery.data(this[i], \"olddisplay\", jQuery.css(this[i], \"display\"));\n\t\t\t\tthis[i].style.display = \"none\";\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t},\n\n\t// Save the old toggle function\n\t_toggle: jQuery.fn.toggle,\n\n\ttoggle: function( fn, fn2 ){\n\t\tvar bool = typeof fn === \"boolean\";\n\n\t\treturn jQuery.isFunction(fn) && jQuery.isFunction(fn2) ?\n\t\t\tthis._toggle.apply( this, arguments ) :\n\t\t\tfn == null || bool ?\n\t\t\t\tthis.each(function(){\n\t\t\t\t\tvar state = bool ? fn : jQuery(this).is(\":hidden\");\n\t\t\t\t\tjQuery(this)[ state ? \"show\" : \"hide\" ]();\n\t\t\t\t}) :\n\t\t\t\tthis.animate(genFx(\"toggle\", 3), fn, fn2);\n\t},\n\n\tfadeTo: function(speed,to,callback){\n\t\treturn this.animate({opacity: to}, speed, callback);\n\t},\n\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar optall = jQuery.speed(speed, easing, callback);\n\n\t\treturn this[ optall.queue === false ? \"each\" : \"queue\" ](function(){\n\t\t\n\t\t\tvar opt = jQuery.extend({}, optall), p,\n\t\t\t\thidden = this.nodeType == 1 && jQuery(this).is(\":hidden\"),\n\t\t\t\tself = this;\n\t\n\t\t\tfor ( p in prop ) {\n\t\t\t\tif ( prop[p] == \"hide\" && hidden || prop[p] == \"show\" && !hidden )\n\t\t\t\t\treturn opt.complete.call(this);\n"},{"path":"./jquery-data/1.3/src/fx.js","lines":[1,395],"code":"var elemdisplay = {},\n\tfxAttrs = [\n\t\t// height animations\n\t\t[ \"height\", \"marginTop\", \"marginBottom\", \"paddingTop\", \"paddingBottom\" ],\n\t\t// width animations\n\t\t[ \"width\", \"marginLeft\", \"marginRight\", \"paddingLeft\", \"paddingRight\" ],\n\t\t// opacity animations\n\t\t[ \"opacity\" ]\n\t];\n\nfunction genFx( type, num ){\n\tvar obj = {};\n\tjQuery.each( fxAttrs.concat.apply([], fxAttrs.slice(0,num)), function(){\n\t\tobj[ this ] = type;\n\t});\n\treturn obj;\n}\n\njQuery.fn.extend({\n\tshow: function(speed,callback){\n\t\tif ( speed ) {\n\t\t\treturn this.animate( genFx(\"show\", 3), speed, callback);\n\t\t} else {\n\t\t\tfor ( var i = 0, l = this.length; i < l; i++ ){\n\t\t\t\tvar old = jQuery.data(this[i], \"olddisplay\");\n\t\t\t\t\n\t\t\t\tthis[i].style.display = old || \"\";\n\t\t\t\t\n\t\t\t\tif ( jQuery.css(this[i], \"display\") === \"none\" ) {\n\t\t\t\t\tvar tagName = this[i].tagName, display;\n\t\t\t\t\t\n\t\t\t\t\tif ( elemdisplay[ tagName ] ) {\n\t\t\t\t\t\tdisplay = elemdisplay[ tagName ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar elem = jQuery(\"<\" + tagName + \" />\").appendTo(\"body\");\n\t\t\t\t\t\t\n\t\t\t\t\t\tdisplay = elem.css(\"display\");\n\t\t\t\t\t\tif ( display === \"none\" )\n\t\t\t\t\t\t\tdisplay = \"block\";\n\t\t\t\t\t\t\n\t\t\t\t\t\telem.remove();\n\t\t\t\t\t\t\n\t\t\t\t\t\telemdisplay[ tagName ] = display;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis[i].style.display = jQuery.data(this[i], \"olddisplay\", display);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\t\t}\n\t},\n\n\thide: function(speed,callback){\n\t\tif ( speed ) {\n\t\t\treturn this.animate( genFx(\"hide\", 3), speed, callback);\n\t\t} else {\n\t\t\tfor ( var i = 0, l = this.length; i < l; i++ ){\n\t\t\t\tvar old = jQuery.data(this[i], \"olddisplay\");\n\t\t\t\tif ( !old && old !== \"none\" )\n\t\t\t\t\tjQuery.data(this[i], \"olddisplay\", jQuery.css(this[i], \"display\"));\n\t\t\t\tthis[i].style.display = \"none\";\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t},\n\n\t// Save the old toggle function\n\t_toggle: jQuery.fn.toggle,\n\n\ttoggle: function( fn, fn2 ){\n\t\tvar bool = typeof fn === \"boolean\";\n\n\t\treturn jQuery.isFunction(fn) && jQuery.isFunction(fn2) ?\n\t\t\tthis._toggle.apply( this, arguments ) :\n\t\t\tfn == null || bool ?\n\t\t\t\tthis.each(function(){\n\t\t\t\t\tvar state = bool ? fn : jQuery(this).is(\":hidden\");\n\t\t\t\t\tjQuery(this)[ state ? \"show\" : \"hide\" ]();\n\t\t\t\t}) :\n\t\t\t\tthis.animate(genFx(\"toggle\", 3), fn, fn2);\n\t},\n\n\tfadeTo: function(speed,to,callback){\n\t\treturn this.animate({opacity: to}, speed, callback);\n\t},\n\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar optall = jQuery.speed(speed, easing, callback);\n\n\t\treturn this[ optall.queue === false ? \"each\" : \"queue\" ](function(){\n\t\t\n\t\t\tvar opt = jQuery.extend({}, optall), p,\n\t\t\t\thidden = this.nodeType == 1 && jQuery(this).is(\":hidden\"),\n\t\t\t\tself = this;\n\t\n\t\t\tfor ( p in prop ) {\n\t\t\t\tif ( prop[p] == \"hide\" && hidden || prop[p] == \"show\" && !hidden )\n\t\t\t\t\treturn opt.complete.call(this);\n"}]},
{"id":"530c0aa97d1124db5b2ece29a374c8b1b944f70e","instances":[{"path":"./jquery-data/1.3.0/src/offset.js","lines":[2,4],"code":"jQuery.fn.offset = function() {\n\tif ( !this[0] ) return { top: 0, left: 0 };\n\tif ( this[0] === this[0].ownerDocument.body ) return jQuery.offset.bodyOffset( this[0] );"},{"path":"./jquery-data/1.3.0/src/offset.js","lines":[12,14],"code":"jQuery.fn.offset = function() {\n\tif ( !this[0] ) return { top: 0, left: 0 };\n\tif ( this[0] === this[0].ownerDocument.body ) return jQuery.offset.bodyOffset( this[0] );"},{"path":"./jquery-data/1.3/src/offset.js","lines":[2,4],"code":"jQuery.fn.offset = function() {\n\tif ( !this[0] ) return { top: 0, left: 0 };\n\tif ( this[0] === this[0].ownerDocument.body ) return jQuery.offset.bodyOffset( this[0] );"},{"path":"./jquery-data/1.3/src/offset.js","lines":[12,14],"code":"jQuery.fn.offset = function() {\n\tif ( !this[0] ) return { top: 0, left: 0 };\n\tif ( this[0] === this[0].ownerDocument.body ) return jQuery.offset.bodyOffset( this[0] );"}]},
{"id":"047629878115acbe300d50ce2ce58d614e012483","instances":[{"path":"./jquery-data/1.3.0/src/selector.js","lines":[1,904],"code":"/*!\n * Sizzle CSS Selector Engine - v0.9.1\n *  Copyright 2009, The Dojo Foundation\n *  Released under the MIT, BSD, and GPL Licenses.\n *  More information: http://sizzlejs.com/\n */\n(function(){\n\nvar chunker = /((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^[\\]]*\\]|[^[\\]]+)+\\]|\\\\.|[^ >+~,(\\[]+)+|[>+~])(\\s*,\\s*)?/g,\n\tdone = 0,\n\ttoString = Object.prototype.toString;\n\nvar Sizzle = function(selector, context, results, seed) {\n\tresults = results || [];\n\tcontext = context || document;\n\n\tif ( context.nodeType !== 1 && context.nodeType !== 9 )\n\t\treturn [];\n\t\n\tif ( !selector || typeof selector !== \"string\" ) {\n\t\treturn results;\n\t}\n\n\tvar parts = [], m, set, checkSet, check, mode, extra, prune = true;\n\t\n\t// Reset the position of the chunker regexp (start from head)\n\tchunker.lastIndex = 0;\n\t\n\twhile ( (m = chunker.exec(selector)) !== null ) {\n\t\tparts.push( m[1] );\n\t\t\n\t\tif ( m[2] ) {\n\t\t\textra = RegExp.rightContext;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( parts.length > 1 && Expr.match.POS.exec( selector ) ) {\n\t\tif ( parts.length === 2 && Expr.relative[ parts[0] ] ) {\n\t\t\tvar later = \"\", match;\n\n\t\t\t// Position selectors must be done after the filter\n\t\t\twhile ( (match = Expr.match.POS.exec( selector )) ) {\n\t\t\t\tlater += match[0];\n\t\t\t\tselector = selector.replace( Expr.match.POS, \"\" );\n\t\t\t}\n\n\t\t\tset = Sizzle.filter( later, Sizzle( /\\s$/.test(selector) ? selector + \"*\" : selector, context ) );\n\t\t} else {\n\t\t\tset = Expr.relative[ parts[0] ] ?\n\t\t\t\t[ context ] :\n\t\t\t\tSizzle( parts.shift(), context );\n\n\t\t\twhile ( parts.length ) {\n\t\t\t\tvar tmpSet = [];\n\n\t\t\t\tselector = parts.shift();\n\t\t\t\tif ( Expr.relative[ selector ] )\n\t\t\t\t\tselector += parts.shift();\n\n\t\t\t\tfor ( var i = 0, l = set.length; i < l; i++ ) {\n\t\t\t\t\tSizzle( selector, set[i], tmpSet );\n\t\t\t\t}\n\n\t\t\t\tset = tmpSet;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvar ret = seed ?\n\t\t\t{ expr: parts.pop(), set: makeArray(seed) } :\n\t\t\tSizzle.find( parts.pop(), parts.length === 1 && context.parentNode ? context.parentNode : context );\n\t\tset = Sizzle.filter( ret.expr, ret.set );\n\n\t\tif ( parts.length > 0 ) {\n\t\t\tcheckSet = makeArray(set);\n\t\t} else {\n\t\t\tprune = false;\n\t\t}\n\n\t\twhile ( parts.length ) {\n\t\t\tvar cur = parts.pop(), pop = cur;\n\n\t\t\tif ( !Expr.relative[ cur ] ) {\n\t\t\t\tcur = \"\";\n\t\t\t} else {\n\t\t\t\tpop = parts.pop();\n\t\t\t}\n\n\t\t\tif ( pop == null ) {\n\t\t\t\tpop = context;\n\t\t\t}\n\n\t\t\tExpr.relative[ cur ]( checkSet, pop, isXML(context) );\n\t\t}\n\t}\n\n\tif ( !checkSet ) {\n\t\tcheckSet = set;\n\t}\n"},{"path":"./jquery-data/1.3/src/selector.js","lines":[1,904],"code":"/*!\n * Sizzle CSS Selector Engine - v0.9.1\n *  Copyright 2009, The Dojo Foundation\n *  Released under the MIT, BSD, and GPL Licenses.\n *  More information: http://sizzlejs.com/\n */\n(function(){\n\nvar chunker = /((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^[\\]]*\\]|[^[\\]]+)+\\]|\\\\.|[^ >+~,(\\[]+)+|[>+~])(\\s*,\\s*)?/g,\n\tdone = 0,\n\ttoString = Object.prototype.toString;\n\nvar Sizzle = function(selector, context, results, seed) {\n\tresults = results || [];\n\tcontext = context || document;\n\n\tif ( context.nodeType !== 1 && context.nodeType !== 9 )\n\t\treturn [];\n\t\n\tif ( !selector || typeof selector !== \"string\" ) {\n\t\treturn results;\n\t}\n\n\tvar parts = [], m, set, checkSet, check, mode, extra, prune = true;\n\t\n\t// Reset the position of the chunker regexp (start from head)\n\tchunker.lastIndex = 0;\n\t\n\twhile ( (m = chunker.exec(selector)) !== null ) {\n\t\tparts.push( m[1] );\n\t\t\n\t\tif ( m[2] ) {\n\t\t\textra = RegExp.rightContext;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( parts.length > 1 && Expr.match.POS.exec( selector ) ) {\n\t\tif ( parts.length === 2 && Expr.relative[ parts[0] ] ) {\n\t\t\tvar later = \"\", match;\n\n\t\t\t// Position selectors must be done after the filter\n\t\t\twhile ( (match = Expr.match.POS.exec( selector )) ) {\n\t\t\t\tlater += match[0];\n\t\t\t\tselector = selector.replace( Expr.match.POS, \"\" );\n\t\t\t}\n\n\t\t\tset = Sizzle.filter( later, Sizzle( /\\s$/.test(selector) ? selector + \"*\" : selector, context ) );\n\t\t} else {\n\t\t\tset = Expr.relative[ parts[0] ] ?\n\t\t\t\t[ context ] :\n\t\t\t\tSizzle( parts.shift(), context );\n\n\t\t\twhile ( parts.length ) {\n\t\t\t\tvar tmpSet = [];\n\n\t\t\t\tselector = parts.shift();\n\t\t\t\tif ( Expr.relative[ selector ] )\n\t\t\t\t\tselector += parts.shift();\n\n\t\t\t\tfor ( var i = 0, l = set.length; i < l; i++ ) {\n\t\t\t\t\tSizzle( selector, set[i], tmpSet );\n\t\t\t\t}\n\n\t\t\t\tset = tmpSet;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvar ret = seed ?\n\t\t\t{ expr: parts.pop(), set: makeArray(seed) } :\n\t\t\tSizzle.find( parts.pop(), parts.length === 1 && context.parentNode ? context.parentNode : context );\n\t\tset = Sizzle.filter( ret.expr, ret.set );\n\n\t\tif ( parts.length > 0 ) {\n\t\t\tcheckSet = makeArray(set);\n\t\t} else {\n\t\t\tprune = false;\n\t\t}\n\n\t\twhile ( parts.length ) {\n\t\t\tvar cur = parts.pop(), pop = cur;\n\n\t\t\tif ( !Expr.relative[ cur ] ) {\n\t\t\t\tcur = \"\";\n\t\t\t} else {\n\t\t\t\tpop = parts.pop();\n\t\t\t}\n\n\t\t\tif ( pop == null ) {\n\t\t\t\tpop = context;\n\t\t\t}\n\n\t\t\tExpr.relative[ cur ]( checkSet, pop, isXML(context) );\n\t\t}\n\t}\n\n\tif ( !checkSet ) {\n\t\tcheckSet = set;\n\t}\n"}]},
{"id":"047629878115acbe300d50ce2ce58d614e012483","instances":[{"path":"./jquery-data/1.3.0/src/selector.js","lines":[1,904],"code":"/*!\n * Sizzle CSS Selector Engine - v0.9.1\n *  Copyright 2009, The Dojo Foundation\n *  Released under the MIT, BSD, and GPL Licenses.\n *  More information: http://sizzlejs.com/\n */\n(function(){\n\nvar chunker = /((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^[\\]]*\\]|[^[\\]]+)+\\]|\\\\.|[^ >+~,(\\[]+)+|[>+~])(\\s*,\\s*)?/g,\n\tdone = 0,\n\ttoString = Object.prototype.toString;\n\nvar Sizzle = function(selector, context, results, seed) {\n\tresults = results || [];\n\tcontext = context || document;\n\n\tif ( context.nodeType !== 1 && context.nodeType !== 9 )\n\t\treturn [];\n\t\n\tif ( !selector || typeof selector !== \"string\" ) {\n\t\treturn results;\n\t}\n\n\tvar parts = [], m, set, checkSet, check, mode, extra, prune = true;\n\t\n\t// Reset the position of the chunker regexp (start from head)\n\tchunker.lastIndex = 0;\n\t\n\twhile ( (m = chunker.exec(selector)) !== null ) {\n\t\tparts.push( m[1] );\n\t\t\n\t\tif ( m[2] ) {\n\t\t\textra = RegExp.rightContext;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( parts.length > 1 && Expr.match.POS.exec( selector ) ) {\n\t\tif ( parts.length === 2 && Expr.relative[ parts[0] ] ) {\n\t\t\tvar later = \"\", match;\n\n\t\t\t// Position selectors must be done after the filter\n\t\t\twhile ( (match = Expr.match.POS.exec( selector )) ) {\n\t\t\t\tlater += match[0];\n\t\t\t\tselector = selector.replace( Expr.match.POS, \"\" );\n\t\t\t}\n\n\t\t\tset = Sizzle.filter( later, Sizzle( /\\s$/.test(selector) ? selector + \"*\" : selector, context ) );\n\t\t} else {\n\t\t\tset = Expr.relative[ parts[0] ] ?\n\t\t\t\t[ context ] :\n\t\t\t\tSizzle( parts.shift(), context );\n\n\t\t\twhile ( parts.length ) {\n\t\t\t\tvar tmpSet = [];\n\n\t\t\t\tselector = parts.shift();\n\t\t\t\tif ( Expr.relative[ selector ] )\n\t\t\t\t\tselector += parts.shift();\n\n\t\t\t\tfor ( var i = 0, l = set.length; i < l; i++ ) {\n\t\t\t\t\tSizzle( selector, set[i], tmpSet );\n\t\t\t\t}\n\n\t\t\t\tset = tmpSet;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvar ret = seed ?\n\t\t\t{ expr: parts.pop(), set: makeArray(seed) } :\n\t\t\tSizzle.find( parts.pop(), parts.length === 1 && context.parentNode ? context.parentNode : context );\n\t\tset = Sizzle.filter( ret.expr, ret.set );\n\n\t\tif ( parts.length > 0 ) {\n\t\t\tcheckSet = makeArray(set);\n\t\t} else {\n\t\t\tprune = false;\n\t\t}\n\n\t\twhile ( parts.length ) {\n\t\t\tvar cur = parts.pop(), pop = cur;\n\n\t\t\tif ( !Expr.relative[ cur ] ) {\n\t\t\t\tcur = \"\";\n\t\t\t} else {\n\t\t\t\tpop = parts.pop();\n\t\t\t}\n\n\t\t\tif ( pop == null ) {\n\t\t\t\tpop = context;\n\t\t\t}\n\n\t\t\tExpr.relative[ cur ]( checkSet, pop, isXML(context) );\n\t\t}\n\t}\n\n\tif ( !checkSet ) {\n\t\tcheckSet = set;\n\t}\n"},{"path":"./jquery-data/1.3/src/selector.js","lines":[1,904],"code":"/*!\n * Sizzle CSS Selector Engine - v0.9.1\n *  Copyright 2009, The Dojo Foundation\n *  Released under the MIT, BSD, and GPL Licenses.\n *  More information: http://sizzlejs.com/\n */\n(function(){\n\nvar chunker = /((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^[\\]]*\\]|[^[\\]]+)+\\]|\\\\.|[^ >+~,(\\[]+)+|[>+~])(\\s*,\\s*)?/g,\n\tdone = 0,\n\ttoString = Object.prototype.toString;\n\nvar Sizzle = function(selector, context, results, seed) {\n\tresults = results || [];\n\tcontext = context || document;\n\n\tif ( context.nodeType !== 1 && context.nodeType !== 9 )\n\t\treturn [];\n\t\n\tif ( !selector || typeof selector !== \"string\" ) {\n\t\treturn results;\n\t}\n\n\tvar parts = [], m, set, checkSet, check, mode, extra, prune = true;\n\t\n\t// Reset the position of the chunker regexp (start from head)\n\tchunker.lastIndex = 0;\n\t\n\twhile ( (m = chunker.exec(selector)) !== null ) {\n\t\tparts.push( m[1] );\n\t\t\n\t\tif ( m[2] ) {\n\t\t\textra = RegExp.rightContext;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( parts.length > 1 && Expr.match.POS.exec( selector ) ) {\n\t\tif ( parts.length === 2 && Expr.relative[ parts[0] ] ) {\n\t\t\tvar later = \"\", match;\n\n\t\t\t// Position selectors must be done after the filter\n\t\t\twhile ( (match = Expr.match.POS.exec( selector )) ) {\n\t\t\t\tlater += match[0];\n\t\t\t\tselector = selector.replace( Expr.match.POS, \"\" );\n\t\t\t}\n\n\t\t\tset = Sizzle.filter( later, Sizzle( /\\s$/.test(selector) ? selector + \"*\" : selector, context ) );\n\t\t} else {\n\t\t\tset = Expr.relative[ parts[0] ] ?\n\t\t\t\t[ context ] :\n\t\t\t\tSizzle( parts.shift(), context );\n\n\t\t\twhile ( parts.length ) {\n\t\t\t\tvar tmpSet = [];\n\n\t\t\t\tselector = parts.shift();\n\t\t\t\tif ( Expr.relative[ selector ] )\n\t\t\t\t\tselector += parts.shift();\n\n\t\t\t\tfor ( var i = 0, l = set.length; i < l; i++ ) {\n\t\t\t\t\tSizzle( selector, set[i], tmpSet );\n\t\t\t\t}\n\n\t\t\t\tset = tmpSet;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvar ret = seed ?\n\t\t\t{ expr: parts.pop(), set: makeArray(seed) } :\n\t\t\tSizzle.find( parts.pop(), parts.length === 1 && context.parentNode ? context.parentNode : context );\n\t\tset = Sizzle.filter( ret.expr, ret.set );\n\n\t\tif ( parts.length > 0 ) {\n\t\t\tcheckSet = makeArray(set);\n\t\t} else {\n\t\t\tprune = false;\n\t\t}\n\n\t\twhile ( parts.length ) {\n\t\t\tvar cur = parts.pop(), pop = cur;\n\n\t\t\tif ( !Expr.relative[ cur ] ) {\n\t\t\t\tcur = \"\";\n\t\t\t} else {\n\t\t\t\tpop = parts.pop();\n\t\t\t}\n\n\t\t\tif ( pop == null ) {\n\t\t\t\tpop = context;\n\t\t\t}\n\n\t\t\tExpr.relative[ cur ]( checkSet, pop, isXML(context) );\n\t\t}\n\t}\n\n\tif ( !checkSet ) {\n\t\tcheckSet = set;\n\t}\n"}]},
{"id":"f509fcfa2e217acc4d86f6e3968971d5f3ac6936","instances":[{"path":"./jquery-data/1.3.0/src/ajax.js","lines":[1,535],"code":"jQuery.fn.extend({\n\t// Keep a copy of the old load\n\t_load: jQuery.fn.load,\n\n\tload: function( url, params, callback ) {\n\t\tif ( typeof url !== \"string\" )\n\t\t\treturn this._load( url );\n\n\t\tvar off = url.indexOf(\" \");\n\t\tif ( off >= 0 ) {\n\t\t\tvar selector = url.slice(off, url.length);\n\t\t\turl = url.slice(0, off);\n\t\t}\n\n\t\t// Default to a GET request\n\t\tvar type = \"GET\";\n\n\t\t// If the second parameter was provided\n\t\tif ( params )\n\t\t\t// If it's a function\n\t\t\tif ( jQuery.isFunction( params ) ) {\n\t\t\t\t// We assume that it's the callback\n\t\t\t\tcallback = params;\n\t\t\t\tparams = null;\n\n\t\t\t// Otherwise, build a param string\n\t\t\t} else if( typeof params === \"object\" ) {\n\t\t\t\tparams = jQuery.param( params );\n\t\t\t\ttype = \"POST\";\n\t\t\t}\n\n\t\tvar self = this;\n\n\t\t// Request the remote document\n\t\tjQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: type,\n\t\t\tdataType: \"html\",\n\t\t\tdata: params,\n\t\t\tcomplete: function(res, status){\n\t\t\t\t// If successful, inject the HTML into all the matched elements\n\t\t\t\tif ( status == \"success\" || status == \"notmodified\" )\n\t\t\t\t\t// See if a selector was specified\n\t\t\t\t\tself.html( selector ?\n\t\t\t\t\t\t// Create a dummy div to hold the results\n\t\t\t\t\t\tjQuery(\"<div/>\")\n\t\t\t\t\t\t\t// inject the contents of the document in, removing the scripts\n\t\t\t\t\t\t\t// to avoid any 'Permission Denied' errors in IE\n\t\t\t\t\t\t\t.append(res.responseText.replace(/<script(.|\\s)*?\\/script>/g, \"\"))\n\n\t\t\t\t\t\t\t// Locate the specified elements\n\t\t\t\t\t\t\t.find(selector) :\n\n\t\t\t\t\t\t// If not, just inject the full result\n\t\t\t\t\t\tres.responseText );\n\n\t\t\t\tif( callback )\n\t\t\t\t\tself.each( callback, [res.responseText, status, res] );\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t},\n\n\tserialize: function() {\n\t\treturn jQuery.param(this.serializeArray());\n\t},\n\tserializeArray: function() {\n\t\treturn this.map(function(){\n\t\t\treturn this.elements ? jQuery.makeArray(this.elements) : this;\n\t\t})\n\t\t.filter(function(){\n\t\t\treturn this.name && !this.disabled &&\n\t\t\t\t(this.checked || /select|textarea/i.test(this.nodeName) ||\n\t\t\t\t\t/text|hidden|password/i.test(this.type));\n\t\t})\n\t\t.map(function(i, elem){\n\t\t\tvar val = jQuery(this).val();\n\t\t\treturn val == null ? null :\n\t\t\t\tjQuery.isArray(val) ?\n\t\t\t\t\tjQuery.map( val, function(val, i){\n\t\t\t\t\t\treturn {name: elem.name, value: val};\n\t\t\t\t\t}) :\n\t\t\t\t\t{name: elem.name, value: val};\n\t\t}).get();\n\t}\n});\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( \"ajaxStart,ajaxStop,ajaxComplete,ajaxError,ajaxSuccess,ajaxSend\".split(\",\"), function(i,o){\n\tjQuery.fn[o] = function(f){\n\t\treturn this.bind(o, f);\n\t};\n});\n\nvar jsc = now();\n\njQuery.extend({\n  \n\tget: function( url, data, callback, type ) {\n\t\t// shift arguments if data argument was ommited"},{"path":"./jquery-data/1.3/src/ajax.js","lines":[1,535],"code":"jQuery.fn.extend({\n\t// Keep a copy of the old load\n\t_load: jQuery.fn.load,\n\n\tload: function( url, params, callback ) {\n\t\tif ( typeof url !== \"string\" )\n\t\t\treturn this._load( url );\n\n\t\tvar off = url.indexOf(\" \");\n\t\tif ( off >= 0 ) {\n\t\t\tvar selector = url.slice(off, url.length);\n\t\t\turl = url.slice(0, off);\n\t\t}\n\n\t\t// Default to a GET request\n\t\tvar type = \"GET\";\n\n\t\t// If the second parameter was provided\n\t\tif ( params )\n\t\t\t// If it's a function\n\t\t\tif ( jQuery.isFunction( params ) ) {\n\t\t\t\t// We assume that it's the callback\n\t\t\t\tcallback = params;\n\t\t\t\tparams = null;\n\n\t\t\t// Otherwise, build a param string\n\t\t\t} else if( typeof params === \"object\" ) {\n\t\t\t\tparams = jQuery.param( params );\n\t\t\t\ttype = \"POST\";\n\t\t\t}\n\n\t\tvar self = this;\n\n\t\t// Request the remote document\n\t\tjQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: type,\n\t\t\tdataType: \"html\",\n\t\t\tdata: params,\n\t\t\tcomplete: function(res, status){\n\t\t\t\t// If successful, inject the HTML into all the matched elements\n\t\t\t\tif ( status == \"success\" || status == \"notmodified\" )\n\t\t\t\t\t// See if a selector was specified\n\t\t\t\t\tself.html( selector ?\n\t\t\t\t\t\t// Create a dummy div to hold the results\n\t\t\t\t\t\tjQuery(\"<div/>\")\n\t\t\t\t\t\t\t// inject the contents of the document in, removing the scripts\n\t\t\t\t\t\t\t// to avoid any 'Permission Denied' errors in IE\n\t\t\t\t\t\t\t.append(res.responseText.replace(/<script(.|\\s)*?\\/script>/g, \"\"))\n\n\t\t\t\t\t\t\t// Locate the specified elements\n\t\t\t\t\t\t\t.find(selector) :\n\n\t\t\t\t\t\t// If not, just inject the full result\n\t\t\t\t\t\tres.responseText );\n\n\t\t\t\tif( callback )\n\t\t\t\t\tself.each( callback, [res.responseText, status, res] );\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t},\n\n\tserialize: function() {\n\t\treturn jQuery.param(this.serializeArray());\n\t},\n\tserializeArray: function() {\n\t\treturn this.map(function(){\n\t\t\treturn this.elements ? jQuery.makeArray(this.elements) : this;\n\t\t})\n\t\t.filter(function(){\n\t\t\treturn this.name && !this.disabled &&\n\t\t\t\t(this.checked || /select|textarea/i.test(this.nodeName) ||\n\t\t\t\t\t/text|hidden|password/i.test(this.type));\n\t\t})\n\t\t.map(function(i, elem){\n\t\t\tvar val = jQuery(this).val();\n\t\t\treturn val == null ? null :\n\t\t\t\tjQuery.isArray(val) ?\n\t\t\t\t\tjQuery.map( val, function(val, i){\n\t\t\t\t\t\treturn {name: elem.name, value: val};\n\t\t\t\t\t}) :\n\t\t\t\t\t{name: elem.name, value: val};\n\t\t}).get();\n\t}\n});\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( \"ajaxStart,ajaxStop,ajaxComplete,ajaxError,ajaxSuccess,ajaxSend\".split(\",\"), function(i,o){\n\tjQuery.fn[o] = function(f){\n\t\treturn this.bind(o, f);\n\t};\n});\n\nvar jsc = now();\n\njQuery.extend({\n  \n\tget: function( url, data, callback, type ) {\n\t\t// shift arguments if data argument was ommited"}]},
{"id":"427d91c8c358d1fd688a0c3f013498bcd0478932","instances":[{"path":"./jquery-data/1.3.0/src/core.js","lines":[1,732],"code":"var \n\t// Will speed up references to window, and allows munging its name.\n\twindow = this,\n\t// Will speed up references to undefined, and allows munging its name.\n\tundefined,\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\t// Map over the $ in case of overwrite\n\t_$ = window.$,\n\n\tjQuery = window.jQuery = window.$ = function( selector, context ) {\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// A simple way to check for HTML strings or ID strings\n\t// (both of which we optimize for)\n\tquickExpr = /^[^<]*(<(.|\\s)+>)[^>]*$|^#([\\w-]+)$/,\n\t// Is it a simple selector\n\tisSimple = /^.[^:#\\[\\.,]*$/;\n\njQuery.fn = jQuery.prototype = {\n\tinit: function( selector, context ) {\n\t\t// Make sure that a selection was provided\n\t\tselector = selector || document;\n\n\t\t// Handle $(DOMElement)\n\t\tif ( selector.nodeType ) {\n\t\t\tthis[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\tthis.context = selector;\n\t\t\treturn this;\n\t\t}\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\t// Are we dealing with HTML string or an ID?\n\t\t\tvar match = quickExpr.exec( selector );\n\n\t\t\t// Verify a match, and that no context was specified for #id\n\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[1] )\n\t\t\t\t\tselector = jQuery.clean( [ match[1] ], context );\n\n\t\t\t\t// HANDLE: $(\"#id\")\n\t\t\t\telse {\n\t\t\t\t\tvar elem = document.getElementById( match[3] );\n\n\t\t\t\t\t// Make sure an element was located\n\t\t\t\t\tif ( elem ){\n\t\t\t\t\t\t// Handle the case where IE and Opera return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id != match[3] )\n\t\t\t\t\t\t\treturn jQuery().find( selector );\n\n\t\t\t\t\t\t// Otherwise, we inject the element directly into the jQuery object\n\t\t\t\t\t\tvar ret = jQuery( elem );\n\t\t\t\t\t\tret.context = document;\n\t\t\t\t\t\tret.selector = selector;\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t\tselector = [];\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, [context])\n\t\t\t// (which is just equivalent to: $(content).find(expr)\n\t\t\t} else\n\t\t\t\treturn jQuery( context ).find( selector );\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) )\n\t\t\treturn jQuery( document ).ready( selector );\n\n\t\t// Make sure that old selector state is passed along\n\t\tif ( selector.selector && selector.context ) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn this.setArray(jQuery.makeArray(selector));\n\t},\n\n\t// Start with an empty selector\n\tselector: \"\",\n\n\t// The current version of jQuery being used\n\tjquery: \"@VERSION\",\n\n\t// The number of elements contained in the matched element set\n\tsize: function() {\n\t\treturn this.length;\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num === undefined ?\n"},{"path":"./jquery-data/1.3/src/core.js","lines":[1,732],"code":"var \n\t// Will speed up references to window, and allows munging its name.\n\twindow = this,\n\t// Will speed up references to undefined, and allows munging its name.\n\tundefined,\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\t// Map over the $ in case of overwrite\n\t_$ = window.$,\n\n\tjQuery = window.jQuery = window.$ = function( selector, context ) {\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// A simple way to check for HTML strings or ID strings\n\t// (both of which we optimize for)\n\tquickExpr = /^[^<]*(<(.|\\s)+>)[^>]*$|^#([\\w-]+)$/,\n\t// Is it a simple selector\n\tisSimple = /^.[^:#\\[\\.,]*$/;\n\njQuery.fn = jQuery.prototype = {\n\tinit: function( selector, context ) {\n\t\t// Make sure that a selection was provided\n\t\tselector = selector || document;\n\n\t\t// Handle $(DOMElement)\n\t\tif ( selector.nodeType ) {\n\t\t\tthis[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\tthis.context = selector;\n\t\t\treturn this;\n\t\t}\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\t// Are we dealing with HTML string or an ID?\n\t\t\tvar match = quickExpr.exec( selector );\n\n\t\t\t// Verify a match, and that no context was specified for #id\n\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[1] )\n\t\t\t\t\tselector = jQuery.clean( [ match[1] ], context );\n\n\t\t\t\t// HANDLE: $(\"#id\")\n\t\t\t\telse {\n\t\t\t\t\tvar elem = document.getElementById( match[3] );\n\n\t\t\t\t\t// Make sure an element was located\n\t\t\t\t\tif ( elem ){\n\t\t\t\t\t\t// Handle the case where IE and Opera return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id != match[3] )\n\t\t\t\t\t\t\treturn jQuery().find( selector );\n\n\t\t\t\t\t\t// Otherwise, we inject the element directly into the jQuery object\n\t\t\t\t\t\tvar ret = jQuery( elem );\n\t\t\t\t\t\tret.context = document;\n\t\t\t\t\t\tret.selector = selector;\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t\tselector = [];\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, [context])\n\t\t\t// (which is just equivalent to: $(content).find(expr)\n\t\t\t} else\n\t\t\t\treturn jQuery( context ).find( selector );\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) )\n\t\t\treturn jQuery( document ).ready( selector );\n\n\t\t// Make sure that old selector state is passed along\n\t\tif ( selector.selector && selector.context ) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn this.setArray(jQuery.makeArray(selector));\n\t},\n\n\t// Start with an empty selector\n\tselector: \"\",\n\n\t// The current version of jQuery being used\n\tjquery: \"@VERSION\",\n\n\t// The number of elements contained in the matched element set\n\tsize: function() {\n\t\treturn this.length;\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num === undefined ?\n"}]},
{"id":"9a7526916606102d2baef3aeccd31a983faf7dee","instances":[{"path":"./jquery-data/1.3.0/src/core.js","lines":[719,1241],"code":"\t// A method for quickly swapping in/out CSS properties to get correct calculations\n\tswap: function( elem, options, callback ) {\n\t\tvar old = {};\n\t\t// Remember the old values, and insert the new ones\n\t\tfor ( var name in options ) {\n\t\t\told[ name ] = elem.style[ name ];\n\t\t\telem.style[ name ] = options[ name ];\n\t\t}\n\n\t\tcallback.call( elem );\n\n\t\t// Revert the old values\n\t\tfor ( var name in options )\n\t\t\telem.style[ name ] = old[ name ];\n\t},\n\n\tcss: function( elem, name, force ) {\n\t\tif ( name == \"width\" || name == \"height\" ) {\n\t\t\tvar val, props = { position: \"absolute\", visibility: \"hidden\", display:\"block\" }, which = name == \"width\" ? [ \"Left\", \"Right\" ] : [ \"Top\", \"Bottom\" ];\n\n\t\t\tfunction getWH() {\n\t\t\t\tval = name == \"width\" ? elem.offsetWidth : elem.offsetHeight;\n\t\t\t\tvar padding = 0, border = 0;\n\t\t\t\tjQuery.each( which, function() {\n\t\t\t\t\tpadding += parseFloat(jQuery.curCSS( elem, \"padding\" + this, true)) || 0;\n\t\t\t\t\tborder += parseFloat(jQuery.curCSS( elem, \"border\" + this + \"Width\", true)) || 0;\n\t\t\t\t});\n\t\t\t\tval -= Math.round(padding + border);\n\t\t\t}\n\n\t\t\tif ( jQuery(elem).is(\":visible\") )\n\t\t\t\tgetWH();\n\t\t\telse\n\t\t\t\tjQuery.swap( elem, props, getWH );\n\n\t\t\treturn Math.max(0, val);\n\t\t}\n\n\t\treturn jQuery.curCSS( elem, name, force );\n\t},\n\n\tcurCSS: function( elem, name, force ) {\n\t\tvar ret, style = elem.style;\n\n\t\t// We need to handle opacity special in IE\n\t\tif ( name == \"opacity\" && !jQuery.support.opacity ) {\n\t\t\tret = jQuery.attr( style, \"opacity\" );\n\n\t\t\treturn ret == \"\" ?\n\t\t\t\t\"1\" :\n\t\t\t\tret;\n\t\t}\n\n\t\t// Make sure we're using the right name for getting the float value\n\t\tif ( name.match( /float/i ) )\n\t\t\tname = styleFloat;\n\n\t\tif ( !force && style && style[ name ] )\n\t\t\tret = style[ name ];\n\n\t\telse if ( defaultView.getComputedStyle ) {\n\n\t\t\t// Only \"float\" is needed here\n\t\t\tif ( name.match( /float/i ) )\n\t\t\t\tname = \"float\";\n\n\t\t\tname = name.replace( /([A-Z])/g, \"-$1\" ).toLowerCase();\n\n\t\t\tvar computedStyle = defaultView.getComputedStyle( elem, null );\n\n\t\t\tif ( computedStyle )\n\t\t\t\tret = computedStyle.getPropertyValue( name );\n\n\t\t\t// We should always get a number back from opacity\n\t\t\tif ( name == \"opacity\" && ret == \"\" )\n\t\t\t\tret = \"1\";\n\n\t\t} else if ( elem.currentStyle ) {\n\t\t\tvar camelCase = name.replace(/\\-(\\w)/g, function(all, letter){\n\t\t\t\treturn letter.toUpperCase();\n\t\t\t});\n\n\t\t\tret = elem.currentStyle[ name ] || elem.currentStyle[ camelCase ];\n\n\t\t\t// From the awesome hack by Dean Edwards\n\t\t\t// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n\n\t\t\t// If we're not dealing with a regular pixel number\n\t\t\t// but a number that has a weird ending, we need to convert it to pixels\n\t\t\tif ( !/^\\d+(px)?$/i.test( ret ) && /^\\d/.test( ret ) ) {\n\t\t\t\t// Remember the original values\n\t\t\t\tvar left = style.left, rsLeft = elem.runtimeStyle.left;\n\n\t\t\t\t// Put in the new values to get a computed value out\n\t\t\t\telem.runtimeStyle.left = elem.currentStyle.left;\n\t\t\t\tstyle.left = ret || 0;\n\t\t\t\tret = style.pixelLeft + \"px\";\n\n\t\t\t\t// Revert the changed values\n\t\t\t\tstyle.left = left;"},{"path":"./jquery-data/1.3/src/core.js","lines":[719,1241],"code":"\t// A method for quickly swapping in/out CSS properties to get correct calculations\n\tswap: function( elem, options, callback ) {\n\t\tvar old = {};\n\t\t// Remember the old values, and insert the new ones\n\t\tfor ( var name in options ) {\n\t\t\told[ name ] = elem.style[ name ];\n\t\t\telem.style[ name ] = options[ name ];\n\t\t}\n\n\t\tcallback.call( elem );\n\n\t\t// Revert the old values\n\t\tfor ( var name in options )\n\t\t\telem.style[ name ] = old[ name ];\n\t},\n\n\tcss: function( elem, name, force ) {\n\t\tif ( name == \"width\" || name == \"height\" ) {\n\t\t\tvar val, props = { position: \"absolute\", visibility: \"hidden\", display:\"block\" }, which = name == \"width\" ? [ \"Left\", \"Right\" ] : [ \"Top\", \"Bottom\" ];\n\n\t\t\tfunction getWH() {\n\t\t\t\tval = name == \"width\" ? elem.offsetWidth : elem.offsetHeight;\n\t\t\t\tvar padding = 0, border = 0;\n\t\t\t\tjQuery.each( which, function() {\n\t\t\t\t\tpadding += parseFloat(jQuery.curCSS( elem, \"padding\" + this, true)) || 0;\n\t\t\t\t\tborder += parseFloat(jQuery.curCSS( elem, \"border\" + this + \"Width\", true)) || 0;\n\t\t\t\t});\n\t\t\t\tval -= Math.round(padding + border);\n\t\t\t}\n\n\t\t\tif ( jQuery(elem).is(\":visible\") )\n\t\t\t\tgetWH();\n\t\t\telse\n\t\t\t\tjQuery.swap( elem, props, getWH );\n\n\t\t\treturn Math.max(0, val);\n\t\t}\n\n\t\treturn jQuery.curCSS( elem, name, force );\n\t},\n\n\tcurCSS: function( elem, name, force ) {\n\t\tvar ret, style = elem.style;\n\n\t\t// We need to handle opacity special in IE\n\t\tif ( name == \"opacity\" && !jQuery.support.opacity ) {\n\t\t\tret = jQuery.attr( style, \"opacity\" );\n\n\t\t\treturn ret == \"\" ?\n\t\t\t\t\"1\" :\n\t\t\t\tret;\n\t\t}\n\n\t\t// Make sure we're using the right name for getting the float value\n\t\tif ( name.match( /float/i ) )\n\t\t\tname = styleFloat;\n\n\t\tif ( !force && style && style[ name ] )\n\t\t\tret = style[ name ];\n\n\t\telse if ( defaultView.getComputedStyle ) {\n\n\t\t\t// Only \"float\" is needed here\n\t\t\tif ( name.match( /float/i ) )\n\t\t\t\tname = \"float\";\n\n\t\t\tname = name.replace( /([A-Z])/g, \"-$1\" ).toLowerCase();\n\n\t\t\tvar computedStyle = defaultView.getComputedStyle( elem, null );\n\n\t\t\tif ( computedStyle )\n\t\t\t\tret = computedStyle.getPropertyValue( name );\n\n\t\t\t// We should always get a number back from opacity\n\t\t\tif ( name == \"opacity\" && ret == \"\" )\n\t\t\t\tret = \"1\";\n\n\t\t} else if ( elem.currentStyle ) {\n\t\t\tvar camelCase = name.replace(/\\-(\\w)/g, function(all, letter){\n\t\t\t\treturn letter.toUpperCase();\n\t\t\t});\n\n\t\t\tret = elem.currentStyle[ name ] || elem.currentStyle[ camelCase ];\n\n\t\t\t// From the awesome hack by Dean Edwards\n\t\t\t// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n\n\t\t\t// If we're not dealing with a regular pixel number\n\t\t\t// but a number that has a weird ending, we need to convert it to pixels\n\t\t\tif ( !/^\\d+(px)?$/i.test( ret ) && /^\\d/.test( ret ) ) {\n\t\t\t\t// Remember the original values\n\t\t\t\tvar left = style.left, rsLeft = elem.runtimeStyle.left;\n\n\t\t\t\t// Put in the new values to get a computed value out\n\t\t\t\telem.runtimeStyle.left = elem.currentStyle.left;\n\t\t\t\tstyle.left = ret || 0;\n\t\t\t\tret = style.pixelLeft + \"px\";\n\n\t\t\t\t// Revert the changed values\n\t\t\t\tstyle.left = left;"}]},
{"id":"cd8a3423afad4f6327ed37ecf3339c5fd54df977","instances":[{"path":"./jquery-data/1.3.0/src/data.js","lines":[1,142],"code":"var expando = \"jQuery\" + now(), uuid = 0, windowData = {};\r\n\r\njQuery.extend({\r\n\tcache: {},\r\n\r\n\tdata: function( elem, name, data ) {\r\n\t\telem = elem == window ?\r\n\t\t\twindowData :\r\n\t\t\telem;\r\n\r\n\t\tvar id = elem[ expando ];\r\n\r\n\t\t// Compute a unique ID for the element\r\n\t\tif ( !id )\r\n\t\t\tid = elem[ expando ] = ++uuid;\r\n\r\n\t\t// Only generate the data cache if we're\r\n\t\t// trying to access or manipulate it\r\n\t\tif ( name && !jQuery.cache[ id ] )\r\n\t\t\tjQuery.cache[ id ] = {};\r\n\r\n\t\t// Prevent overriding the named cache with undefined values\r\n\t\tif ( data !== undefined )\r\n\t\t\tjQuery.cache[ id ][ name ] = data;\r\n\r\n\t\t// Return the named cache data, or the ID for the element\r\n\t\treturn name ?\r\n\t\t\tjQuery.cache[ id ][ name ] :\r\n\t\t\tid;\r\n\t},\r\n\r\n\tremoveData: function( elem, name ) {\r\n\t\telem = elem == window ?\r\n\t\t\twindowData :\r\n\t\t\telem;\r\n\r\n\t\tvar id = elem[ expando ];\r\n\r\n\t\t// If we want to remove a specific section of the element's data\r\n\t\tif ( name ) {\r\n\t\t\tif ( jQuery.cache[ id ] ) {\r\n\t\t\t\t// Remove the section of cache data\r\n\t\t\t\tdelete jQuery.cache[ id ][ name ];\r\n\r\n\t\t\t\t// If we've removed all the data, remove the element's cache\r\n\t\t\t\tname = \"\";\r\n\r\n\t\t\t\tfor ( name in jQuery.cache[ id ] )\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tif ( !name )\r\n\t\t\t\t\tjQuery.removeData( elem );\r\n\t\t\t}\r\n\r\n\t\t// Otherwise, we want to remove all of the element's data\r\n\t\t} else {\r\n\t\t\t// Clean up the element expando\r\n\t\t\ttry {\r\n\t\t\t\tdelete elem[ expando ];\r\n\t\t\t} catch(e){\r\n\t\t\t\t// IE has trouble directly removing the expando\r\n\t\t\t\t// but it's ok with using removeAttribute\r\n\t\t\t\tif ( elem.removeAttribute )\r\n\t\t\t\t\telem.removeAttribute( expando );\r\n\t\t\t}\r\n\r\n\t\t\t// Completely remove the data cache\r\n\t\t\tdelete jQuery.cache[ id ];\r\n\t\t}\r\n\t},\r\n\tqueue: function( elem, type, data ) {\r\n\t\tif ( elem ){\r\n\t\r\n\t\t\ttype = (type || \"fx\") + \"queue\";\r\n\t\r\n\t\t\tvar q = jQuery.data( elem, type );\r\n\t\r\n\t\t\tif ( !q || jQuery.isArray(data) )\r\n\t\t\t\tq = jQuery.data( elem, type, jQuery.makeArray(data) );\r\n\t\t\telse if( data )\r\n\t\t\t\tq.push( data );\r\n\t\r\n\t\t}\r\n\t\treturn q;\r\n\t},\r\n\r\n\tdequeue: function( elem, type ){\r\n\t\tvar queue = jQuery.queue( elem, type ),\r\n\t\t\tfn = queue.shift();\r\n\t\t\r\n\t\tif( !type || type === \"fx\" )\r\n\t\t\tfn = queue[0];\r\n\t\t\t\r\n\t\tif( fn !== undefined )\r\n\t\t\tfn.call(elem);\r\n\t}\r\n});\r\n\r\njQuery.fn.extend({\r\n\tdata: function( key, value ){\r"},{"path":"./jquery-data/1.3/src/data.js","lines":[1,142],"code":"var expando = \"jQuery\" + now(), uuid = 0, windowData = {};\r\n\r\njQuery.extend({\r\n\tcache: {},\r\n\r\n\tdata: function( elem, name, data ) {\r\n\t\telem = elem == window ?\r\n\t\t\twindowData :\r\n\t\t\telem;\r\n\r\n\t\tvar id = elem[ expando ];\r\n\r\n\t\t// Compute a unique ID for the element\r\n\t\tif ( !id )\r\n\t\t\tid = elem[ expando ] = ++uuid;\r\n\r\n\t\t// Only generate the data cache if we're\r\n\t\t// trying to access or manipulate it\r\n\t\tif ( name && !jQuery.cache[ id ] )\r\n\t\t\tjQuery.cache[ id ] = {};\r\n\r\n\t\t// Prevent overriding the named cache with undefined values\r\n\t\tif ( data !== undefined )\r\n\t\t\tjQuery.cache[ id ][ name ] = data;\r\n\r\n\t\t// Return the named cache data, or the ID for the element\r\n\t\treturn name ?\r\n\t\t\tjQuery.cache[ id ][ name ] :\r\n\t\t\tid;\r\n\t},\r\n\r\n\tremoveData: function( elem, name ) {\r\n\t\telem = elem == window ?\r\n\t\t\twindowData :\r\n\t\t\telem;\r\n\r\n\t\tvar id = elem[ expando ];\r\n\r\n\t\t// If we want to remove a specific section of the element's data\r\n\t\tif ( name ) {\r\n\t\t\tif ( jQuery.cache[ id ] ) {\r\n\t\t\t\t// Remove the section of cache data\r\n\t\t\t\tdelete jQuery.cache[ id ][ name ];\r\n\r\n\t\t\t\t// If we've removed all the data, remove the element's cache\r\n\t\t\t\tname = \"\";\r\n\r\n\t\t\t\tfor ( name in jQuery.cache[ id ] )\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tif ( !name )\r\n\t\t\t\t\tjQuery.removeData( elem );\r\n\t\t\t}\r\n\r\n\t\t// Otherwise, we want to remove all of the element's data\r\n\t\t} else {\r\n\t\t\t// Clean up the element expando\r\n\t\t\ttry {\r\n\t\t\t\tdelete elem[ expando ];\r\n\t\t\t} catch(e){\r\n\t\t\t\t// IE has trouble directly removing the expando\r\n\t\t\t\t// but it's ok with using removeAttribute\r\n\t\t\t\tif ( elem.removeAttribute )\r\n\t\t\t\t\telem.removeAttribute( expando );\r\n\t\t\t}\r\n\r\n\t\t\t// Completely remove the data cache\r\n\t\t\tdelete jQuery.cache[ id ];\r\n\t\t}\r\n\t},\r\n\tqueue: function( elem, type, data ) {\r\n\t\tif ( elem ){\r\n\t\r\n\t\t\ttype = (type || \"fx\") + \"queue\";\r\n\t\r\n\t\t\tvar q = jQuery.data( elem, type );\r\n\t\r\n\t\t\tif ( !q || jQuery.isArray(data) )\r\n\t\t\t\tq = jQuery.data( elem, type, jQuery.makeArray(data) );\r\n\t\t\telse if( data )\r\n\t\t\t\tq.push( data );\r\n\t\r\n\t\t}\r\n\t\treturn q;\r\n\t},\r\n\r\n\tdequeue: function( elem, type ){\r\n\t\tvar queue = jQuery.queue( elem, type ),\r\n\t\t\tfn = queue.shift();\r\n\t\t\r\n\t\tif( !type || type === \"fx\" )\r\n\t\t\tfn = queue[0];\r\n\t\t\t\r\n\t\tif( fn !== undefined )\r\n\t\t\tfn.call(elem);\r\n\t}\r\n});\r\n\r\njQuery.fn.extend({\r\n\tdata: function( key, value ){\r"}]},
{"id":"4da296c2170947f64b911046d9ca9bf3135fd533","instances":[{"path":"./jquery-data/1.3.0/src/dimensions.js","lines":[1,47],"code":"// Create innerHeight, innerWidth, outerHeight and outerWidth methods\njQuery.each([ \"Height\", \"Width\" ], function(i, name){\n\n\tvar tl = i ? \"Left\"  : \"Top\",  // top or left\n\t\tbr = i ? \"Right\" : \"Bottom\"; // bottom or right\n\n\t// innerHeight and innerWidth\n\tjQuery.fn[\"inner\" + name] = function(){\n\t\treturn this[ name.toLowerCase() ]() +\n\t\t\tnum(this, \"padding\" + tl) +\n\t\t\tnum(this, \"padding\" + br);\n\t};\n\n\t// outerHeight and outerWidth\n\tjQuery.fn[\"outer\" + name] = function(margin) {\n\t\treturn this[\"inner\" + name]() +\n\t\t\tnum(this, \"border\" + tl + \"Width\") +\n\t\t\tnum(this, \"border\" + br + \"Width\") +\n\t\t\t(margin ?\n\t\t\t\tnum(this, \"margin\" + tl) + num(this, \"margin\" + br) : 0);\n\t};\n\t\n\tvar type = name.toLowerCase();\n\n\tjQuery.fn[ type ] = function( size ) {\n\t\t// Get window width or height\n\t\treturn this[0] == window ?\n\t\t\t// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode\n\t\t\tdocument.compatMode == \"CSS1Compat\" && document.documentElement[ \"client\" + name ] ||\n\t\t\tdocument.body[ \"client\" + name ] :\n\n\t\t\t// Get document width or height\n\t\t\tthis[0] == document ?\n\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height], whichever is greater\n\t\t\t\tMath.max(\n\t\t\t\t\tdocument.documentElement[\"client\" + name],\n\t\t\t\t\tdocument.body[\"scroll\" + name], document.documentElement[\"scroll\" + name],\n\t\t\t\t\tdocument.body[\"offset\" + name], document.documentElement[\"offset\" + name]\n\t\t\t\t) :\n\n\t\t\t\t// Get or set width or height on the element\n\t\t\t\tsize === undefined ?\n\t\t\t\t\t// Get width or height on the element\n\t\t\t\t\t(this.length ? jQuery.css( this[0], type ) : null) :\n\n\t\t\t\t\t// Set the width or height on the element (default to pixels if value is unitless)\n\t\t\t\t\tthis.css( type, typeof size === \"string\" ? size : size + \"px\" );"},{"path":"./jquery-data/1.3/src/dimensions.js","lines":[1,47],"code":"// Create innerHeight, innerWidth, outerHeight and outerWidth methods\njQuery.each([ \"Height\", \"Width\" ], function(i, name){\n\n\tvar tl = i ? \"Left\"  : \"Top\",  // top or left\n\t\tbr = i ? \"Right\" : \"Bottom\"; // bottom or right\n\n\t// innerHeight and innerWidth\n\tjQuery.fn[\"inner\" + name] = function(){\n\t\treturn this[ name.toLowerCase() ]() +\n\t\t\tnum(this, \"padding\" + tl) +\n\t\t\tnum(this, \"padding\" + br);\n\t};\n\n\t// outerHeight and outerWidth\n\tjQuery.fn[\"outer\" + name] = function(margin) {\n\t\treturn this[\"inner\" + name]() +\n\t\t\tnum(this, \"border\" + tl + \"Width\") +\n\t\t\tnum(this, \"border\" + br + \"Width\") +\n\t\t\t(margin ?\n\t\t\t\tnum(this, \"margin\" + tl) + num(this, \"margin\" + br) : 0);\n\t};\n\t\n\tvar type = name.toLowerCase();\n\n\tjQuery.fn[ type ] = function( size ) {\n\t\t// Get window width or height\n\t\treturn this[0] == window ?\n\t\t\t// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode\n\t\t\tdocument.compatMode == \"CSS1Compat\" && document.documentElement[ \"client\" + name ] ||\n\t\t\tdocument.body[ \"client\" + name ] :\n\n\t\t\t// Get document width or height\n\t\t\tthis[0] == document ?\n\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height], whichever is greater\n\t\t\t\tMath.max(\n\t\t\t\t\tdocument.documentElement[\"client\" + name],\n\t\t\t\t\tdocument.body[\"scroll\" + name], document.documentElement[\"scroll\" + name],\n\t\t\t\t\tdocument.body[\"offset\" + name], document.documentElement[\"offset\" + name]\n\t\t\t\t) :\n\n\t\t\t\t// Get or set width or height on the element\n\t\t\t\tsize === undefined ?\n\t\t\t\t\t// Get width or height on the element\n\t\t\t\t\t(this.length ? jQuery.css( this[0], type ) : null) :\n\n\t\t\t\t\t// Set the width or height on the element (default to pixels if value is unitless)\n\t\t\t\t\tthis.css( type, typeof size === \"string\" ? size : size + \"px\" );"}]},
{"id":"6f50f03638407c64731d36ab31616cb158b088bb","instances":[{"path":"./jquery-data/1.3.0/src/event.js","lines":[1,131],"code":"/*\n * A number of helper functions used for managing events.\n * Many of the ideas behind this code originated from\n * Dean Edwards' addEvent library.\n */\njQuery.event = {\n\n\t// Bind an event to an element\n\t// Original by Dean Edwards\n\tadd: function(elem, types, handler, data) {\n\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\treturn;\n\n\t\t// For whatever reason, IE has trouble passing the window object\n\t\t// around, causing it to be cloned in the process\n\t\tif ( elem.setInterval && elem != window )\n\t\t\telem = window;\n\n\t\t// Make sure that the function being executed has a unique ID\n\t\tif ( !handler.guid )\n\t\t\thandler.guid = this.guid++;\n\n\t\t// if data is passed, bind to handler\n\t\tif ( data !== undefined ) {\n\t\t\t// Create temporary function pointer to original handler\n\t\t\tvar fn = handler;\n\n\t\t\t// Create unique handler function, wrapped around original handler\n\t\t\thandler = this.proxy( fn );\n\n\t\t\t// Store data in unique handler\n\t\t\thandler.data = data;\n\t\t}\n\n\t\t// Init the element's event structure\n\t\tvar events = jQuery.data(elem, \"events\") || jQuery.data(elem, \"events\", {}),\n\t\t\thandle = jQuery.data(elem, \"handle\") || jQuery.data(elem, \"handle\", function(){\n\t\t\t\t// Handle the second event of a trigger and when\n\t\t\t\t// an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && !jQuery.event.triggered ?\n\t\t\t\t\tjQuery.event.handle.apply(arguments.callee.elem, arguments) :\n\t\t\t\t\tundefined;\n\t\t\t});\n\t\t// Add elem as a property of the handle function\n\t\t// This is to prevent a memory leak with non-native\n\t\t// event in IE.\n\t\thandle.elem = elem;\n\n\t\t// Handle multiple events separated by a space\n\t\t// jQuery(...).bind(\"mouseover mouseout\", fn);\n\t\tjQuery.each(types.split(/\\s+/), function(index, type) {\n\t\t\t// Namespaced event handlers\n\t\t\tvar namespaces = type.split(\".\");\n\t\t\ttype = namespaces.shift();\n\t\t\thandler.type = namespaces.slice().sort().join(\".\");\n\n\t\t\t// Get the current list of functions bound to this event\n\t\t\tvar handlers = events[type];\n\t\t\t\n\t\t\tif ( jQuery.event.specialAll[type] )\n\t\t\t\tjQuery.event.specialAll[type].setup.call(elem, data, namespaces);\n\n\t\t\t// Init the event handler queue\n\t\t\tif (!handlers) {\n\t\t\t\thandlers = events[type] = {};\n\n\t\t\t\t// Check for a special event handler\n\t\t\t\t// Only use addEventListener/attachEvent if the special\n\t\t\t\t// events handler returns false\n\t\t\t\tif ( !jQuery.event.special[type] || jQuery.event.special[type].setup.call(elem, data, namespaces) === false ) {\n\t\t\t\t\t// Bind the global event handler to the element\n\t\t\t\t\tif (elem.addEventListener)\n\t\t\t\t\t\telem.addEventListener(type, handle, false);\n\t\t\t\t\telse if (elem.attachEvent)\n\t\t\t\t\t\telem.attachEvent(\"on\" + type, handle);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add the function to the element's handler list\n\t\t\thandlers[handler.guid] = handler;\n\n\t\t\t// Keep track of which events have been used, for global triggering\n\t\t\tjQuery.event.global[type] = true;\n\t\t});\n\n\t\t// Nullify elem to prevent memory leaks in IE\n\t\telem = null;\n\t},\n\n\tguid: 1,\n\tglobal: {},\n\n\t// Detach an event or set of events from an element\n\tremove: function(elem, types, handler) {\n\t\t// don't do events on text and comment nodes\n\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\treturn;\n\n\t\tvar events = jQuery.data(elem, \"events\"), ret, index;\n"},{"path":"./jquery-data/1.3/src/event.js","lines":[1,131],"code":"/*\n * A number of helper functions used for managing events.\n * Many of the ideas behind this code originated from\n * Dean Edwards' addEvent library.\n */\njQuery.event = {\n\n\t// Bind an event to an element\n\t// Original by Dean Edwards\n\tadd: function(elem, types, handler, data) {\n\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\treturn;\n\n\t\t// For whatever reason, IE has trouble passing the window object\n\t\t// around, causing it to be cloned in the process\n\t\tif ( elem.setInterval && elem != window )\n\t\t\telem = window;\n\n\t\t// Make sure that the function being executed has a unique ID\n\t\tif ( !handler.guid )\n\t\t\thandler.guid = this.guid++;\n\n\t\t// if data is passed, bind to handler\n\t\tif ( data !== undefined ) {\n\t\t\t// Create temporary function pointer to original handler\n\t\t\tvar fn = handler;\n\n\t\t\t// Create unique handler function, wrapped around original handler\n\t\t\thandler = this.proxy( fn );\n\n\t\t\t// Store data in unique handler\n\t\t\thandler.data = data;\n\t\t}\n\n\t\t// Init the element's event structure\n\t\tvar events = jQuery.data(elem, \"events\") || jQuery.data(elem, \"events\", {}),\n\t\t\thandle = jQuery.data(elem, \"handle\") || jQuery.data(elem, \"handle\", function(){\n\t\t\t\t// Handle the second event of a trigger and when\n\t\t\t\t// an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && !jQuery.event.triggered ?\n\t\t\t\t\tjQuery.event.handle.apply(arguments.callee.elem, arguments) :\n\t\t\t\t\tundefined;\n\t\t\t});\n\t\t// Add elem as a property of the handle function\n\t\t// This is to prevent a memory leak with non-native\n\t\t// event in IE.\n\t\thandle.elem = elem;\n\n\t\t// Handle multiple events separated by a space\n\t\t// jQuery(...).bind(\"mouseover mouseout\", fn);\n\t\tjQuery.each(types.split(/\\s+/), function(index, type) {\n\t\t\t// Namespaced event handlers\n\t\t\tvar namespaces = type.split(\".\");\n\t\t\ttype = namespaces.shift();\n\t\t\thandler.type = namespaces.slice().sort().join(\".\");\n\n\t\t\t// Get the current list of functions bound to this event\n\t\t\tvar handlers = events[type];\n\t\t\t\n\t\t\tif ( jQuery.event.specialAll[type] )\n\t\t\t\tjQuery.event.specialAll[type].setup.call(elem, data, namespaces);\n\n\t\t\t// Init the event handler queue\n\t\t\tif (!handlers) {\n\t\t\t\thandlers = events[type] = {};\n\n\t\t\t\t// Check for a special event handler\n\t\t\t\t// Only use addEventListener/attachEvent if the special\n\t\t\t\t// events handler returns false\n\t\t\t\tif ( !jQuery.event.special[type] || jQuery.event.special[type].setup.call(elem, data, namespaces) === false ) {\n\t\t\t\t\t// Bind the global event handler to the element\n\t\t\t\t\tif (elem.addEventListener)\n\t\t\t\t\t\telem.addEventListener(type, handle, false);\n\t\t\t\t\telse if (elem.attachEvent)\n\t\t\t\t\t\telem.attachEvent(\"on\" + type, handle);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add the function to the element's handler list\n\t\t\thandlers[handler.guid] = handler;\n\n\t\t\t// Keep track of which events have been used, for global triggering\n\t\t\tjQuery.event.global[type] = true;\n\t\t});\n\n\t\t// Nullify elem to prevent memory leaks in IE\n\t\telem = null;\n\t},\n\n\tguid: 1,\n\tglobal: {},\n\n\t// Detach an event or set of events from an element\n\tremove: function(elem, types, handler) {\n\t\t// don't do events on text and comment nodes\n\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\treturn;\n\n\t\tvar events = jQuery.data(elem, \"events\"), ret, index;\n"}]},
{"id":"7c4f5a2dced2e470fa704474b3cfcd2688b99fdb","instances":[{"path":"./jquery-data/1.3.0/src/offset.js","lines":[1,153],"code":"if ( document.documentElement[\"getBoundingClientRect\"] )\n\tjQuery.fn.offset = function() {\n\t\tif ( !this[0] ) return { top: 0, left: 0 };\n\t\tif ( this[0] === this[0].ownerDocument.body ) return jQuery.offset.bodyOffset( this[0] );\n\t\tvar box  = this[0].getBoundingClientRect(), doc = this[0].ownerDocument, body = doc.body, docElem = doc.documentElement,\n\t\t\tclientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,\n\t\t\ttop  = box.top  + (self.pageYOffset || jQuery.boxModel && docElem.scrollTop  || body.scrollTop ) - clientTop,\n\t\t\tleft = box.left + (self.pageXOffset || jQuery.boxModel && docElem.scrollLeft || body.scrollLeft) - clientLeft;\n\t\treturn { top: top, left: left };\n\t};\nelse \n\tjQuery.fn.offset = function() {\n\t\tif ( !this[0] ) return { top: 0, left: 0 };\n\t\tif ( this[0] === this[0].ownerDocument.body ) return jQuery.offset.bodyOffset( this[0] );\n\t\tjQuery.offset.initialized || jQuery.offset.initialize();\n\n\t\tvar elem = this[0], offsetParent = elem.offsetParent, prevOffsetParent = elem,\n\t\t\tdoc = elem.ownerDocument, computedStyle, docElem = doc.documentElement,\n\t\t\tbody = doc.body, defaultView = doc.defaultView,\n\t\t\tprevComputedStyle = defaultView.getComputedStyle(elem, null),\n\t\t\ttop = elem.offsetTop, left = elem.offsetLeft;\n\n\t\twhile ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {\n\t\t\tcomputedStyle = defaultView.getComputedStyle(elem, null);\n\t\t\ttop -= elem.scrollTop, left -= elem.scrollLeft;\n\t\t\tif ( elem === offsetParent ) {\n\t\t\t\ttop += elem.offsetTop, left += elem.offsetLeft;\n\t\t\t\tif ( jQuery.offset.doesNotAddBorder && !(jQuery.offset.doesAddBorderForTableAndCells && /^t(able|d|h)$/i.test(elem.tagName)) )\n\t\t\t\t\ttop  += parseInt( computedStyle.borderTopWidth,  10) || 0,\n\t\t\t\t\tleft += parseInt( computedStyle.borderLeftWidth, 10) || 0;\n\t\t\t\tprevOffsetParent = offsetParent, offsetParent = elem.offsetParent;\n\t\t\t}\n\t\t\tif ( jQuery.offset.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== \"visible\" )\n\t\t\t\ttop  += parseInt( computedStyle.borderTopWidth,  10) || 0,\n\t\t\t\tleft += parseInt( computedStyle.borderLeftWidth, 10) || 0;\n\t\t\tprevComputedStyle = computedStyle;\n\t\t}\n\n\t\tif ( prevComputedStyle.position === \"relative\" || prevComputedStyle.position === \"static\" )\n\t\t\ttop  += body.offsetTop,\n\t\t\tleft += body.offsetLeft;\n\n\t\tif ( prevComputedStyle.position === \"fixed\" )\n\t\t\ttop  += Math.max(docElem.scrollTop, body.scrollTop),\n\t\t\tleft += Math.max(docElem.scrollLeft, body.scrollLeft);\n\n\t\treturn { top: top, left: left };\n\t};\n\njQuery.offset = {\n\tinitialize: function() {\n\t\tif ( this.initialized ) return;\n\t\tvar body = document.body, container = document.createElement('div'), innerDiv, checkDiv, table, td, rules, prop, bodyMarginTop = body.style.marginTop,\n\t\t\thtml = '<div style=\"position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;\"><div></div></div><table style=\"position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;\"cellpadding=\"0\"cellspacing=\"0\"><tr><td></td></tr></table>';\n\n\t\trules = { position: 'absolute', top: 0, left: 0, margin: 0, border: 0, width: '1px', height: '1px', visibility: 'hidden' };\n\t\tfor ( prop in rules ) container.style[prop] = rules[prop];\n\n\t\tcontainer.innerHTML = html;\n\t\tbody.insertBefore(container, body.firstChild);\n\t\tinnerDiv = container.firstChild, checkDiv = innerDiv.firstChild, td = innerDiv.nextSibling.firstChild.firstChild;\n\n\t\tthis.doesNotAddBorder = (checkDiv.offsetTop !== 5);\n\t\tthis.doesAddBorderForTableAndCells = (td.offsetTop === 5);\n\n\t\tinnerDiv.style.overflow = 'hidden', innerDiv.style.position = 'relative';\n\t\tthis.subtractsBorderForOverflowNotVisible = (checkDiv.offsetTop === -5);\n\n\t\tbody.style.marginTop = '1px';\n\t\tthis.doesNotIncludeMarginInBodyOffset = (body.offsetTop === 0);\n\t\tbody.style.marginTop = bodyMarginTop;\n\n\t\tbody.removeChild(container);\n\t\tthis.initialized = true;\n\t},\n\n\tbodyOffset: function(body) {\n\t\tjQuery.offset.initialized || jQuery.offset.initialize();\n\t\tvar top = body.offsetTop, left = body.offsetLeft;\n\t\tif ( jQuery.offset.doesNotIncludeMarginInBodyOffset )\n\t\t\ttop  += parseInt( jQuery.curCSS(body, 'marginTop',  true), 10 ) || 0,\n\t\t\tleft += parseInt( jQuery.curCSS(body, 'marginLeft', true), 10 ) || 0;\n\t\treturn { top: top, left: left };\n\t}\n};\n\n\njQuery.fn.extend({\n\tposition: function() {\n\t\tvar left = 0, top = 0, results;\n\n\t\tif ( this[0] ) {\n\t\t\t// Get *real* offsetParent\n\t\t\tvar offsetParent = this.offsetParent(),\n\n\t\t\t// Get correct offsets\n\t\t\toffset       = this.offset(),\n\t\t\tparentOffset = /^body|html$/i.test(offsetParent[0].tagName) ? { top: 0, left: 0 } : offsetParent.offset();\n\n\t\t\t// Subtract element margins"},{"path":"./jquery-data/1.3/src/offset.js","lines":[1,153],"code":"if ( document.documentElement[\"getBoundingClientRect\"] )\n\tjQuery.fn.offset = function() {\n\t\tif ( !this[0] ) return { top: 0, left: 0 };\n\t\tif ( this[0] === this[0].ownerDocument.body ) return jQuery.offset.bodyOffset( this[0] );\n\t\tvar box  = this[0].getBoundingClientRect(), doc = this[0].ownerDocument, body = doc.body, docElem = doc.documentElement,\n\t\t\tclientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,\n\t\t\ttop  = box.top  + (self.pageYOffset || jQuery.boxModel && docElem.scrollTop  || body.scrollTop ) - clientTop,\n\t\t\tleft = box.left + (self.pageXOffset || jQuery.boxModel && docElem.scrollLeft || body.scrollLeft) - clientLeft;\n\t\treturn { top: top, left: left };\n\t};\nelse \n\tjQuery.fn.offset = function() {\n\t\tif ( !this[0] ) return { top: 0, left: 0 };\n\t\tif ( this[0] === this[0].ownerDocument.body ) return jQuery.offset.bodyOffset( this[0] );\n\t\tjQuery.offset.initialized || jQuery.offset.initialize();\n\n\t\tvar elem = this[0], offsetParent = elem.offsetParent, prevOffsetParent = elem,\n\t\t\tdoc = elem.ownerDocument, computedStyle, docElem = doc.documentElement,\n\t\t\tbody = doc.body, defaultView = doc.defaultView,\n\t\t\tprevComputedStyle = defaultView.getComputedStyle(elem, null),\n\t\t\ttop = elem.offsetTop, left = elem.offsetLeft;\n\n\t\twhile ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {\n\t\t\tcomputedStyle = defaultView.getComputedStyle(elem, null);\n\t\t\ttop -= elem.scrollTop, left -= elem.scrollLeft;\n\t\t\tif ( elem === offsetParent ) {\n\t\t\t\ttop += elem.offsetTop, left += elem.offsetLeft;\n\t\t\t\tif ( jQuery.offset.doesNotAddBorder && !(jQuery.offset.doesAddBorderForTableAndCells && /^t(able|d|h)$/i.test(elem.tagName)) )\n\t\t\t\t\ttop  += parseInt( computedStyle.borderTopWidth,  10) || 0,\n\t\t\t\t\tleft += parseInt( computedStyle.borderLeftWidth, 10) || 0;\n\t\t\t\tprevOffsetParent = offsetParent, offsetParent = elem.offsetParent;\n\t\t\t}\n\t\t\tif ( jQuery.offset.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== \"visible\" )\n\t\t\t\ttop  += parseInt( computedStyle.borderTopWidth,  10) || 0,\n\t\t\t\tleft += parseInt( computedStyle.borderLeftWidth, 10) || 0;\n\t\t\tprevComputedStyle = computedStyle;\n\t\t}\n\n\t\tif ( prevComputedStyle.position === \"relative\" || prevComputedStyle.position === \"static\" )\n\t\t\ttop  += body.offsetTop,\n\t\t\tleft += body.offsetLeft;\n\n\t\tif ( prevComputedStyle.position === \"fixed\" )\n\t\t\ttop  += Math.max(docElem.scrollTop, body.scrollTop),\n\t\t\tleft += Math.max(docElem.scrollLeft, body.scrollLeft);\n\n\t\treturn { top: top, left: left };\n\t};\n\njQuery.offset = {\n\tinitialize: function() {\n\t\tif ( this.initialized ) return;\n\t\tvar body = document.body, container = document.createElement('div'), innerDiv, checkDiv, table, td, rules, prop, bodyMarginTop = body.style.marginTop,\n\t\t\thtml = '<div style=\"position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;\"><div></div></div><table style=\"position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;\"cellpadding=\"0\"cellspacing=\"0\"><tr><td></td></tr></table>';\n\n\t\trules = { position: 'absolute', top: 0, left: 0, margin: 0, border: 0, width: '1px', height: '1px', visibility: 'hidden' };\n\t\tfor ( prop in rules ) container.style[prop] = rules[prop];\n\n\t\tcontainer.innerHTML = html;\n\t\tbody.insertBefore(container, body.firstChild);\n\t\tinnerDiv = container.firstChild, checkDiv = innerDiv.firstChild, td = innerDiv.nextSibling.firstChild.firstChild;\n\n\t\tthis.doesNotAddBorder = (checkDiv.offsetTop !== 5);\n\t\tthis.doesAddBorderForTableAndCells = (td.offsetTop === 5);\n\n\t\tinnerDiv.style.overflow = 'hidden', innerDiv.style.position = 'relative';\n\t\tthis.subtractsBorderForOverflowNotVisible = (checkDiv.offsetTop === -5);\n\n\t\tbody.style.marginTop = '1px';\n\t\tthis.doesNotIncludeMarginInBodyOffset = (body.offsetTop === 0);\n\t\tbody.style.marginTop = bodyMarginTop;\n\n\t\tbody.removeChild(container);\n\t\tthis.initialized = true;\n\t},\n\n\tbodyOffset: function(body) {\n\t\tjQuery.offset.initialized || jQuery.offset.initialize();\n\t\tvar top = body.offsetTop, left = body.offsetLeft;\n\t\tif ( jQuery.offset.doesNotIncludeMarginInBodyOffset )\n\t\t\ttop  += parseInt( jQuery.curCSS(body, 'marginTop',  true), 10 ) || 0,\n\t\t\tleft += parseInt( jQuery.curCSS(body, 'marginLeft', true), 10 ) || 0;\n\t\treturn { top: top, left: left };\n\t}\n};\n\n\njQuery.fn.extend({\n\tposition: function() {\n\t\tvar left = 0, top = 0, results;\n\n\t\tif ( this[0] ) {\n\t\t\t// Get *real* offsetParent\n\t\t\tvar offsetParent = this.offsetParent(),\n\n\t\t\t// Get correct offsets\n\t\t\toffset       = this.offset(),\n\t\t\tparentOffset = /^body|html$/i.test(offsetParent[0].tagName) ? { top: 0, left: 0 } : offsetParent.offset();\n\n\t\t\t// Subtract element margins"}]},
{"id":"31c93c055df88b27034a16f39dfbf756e38e5104","instances":[{"path":"./jquery-data/1.3.0/src/support.js","lines":[1,114],"code":"(function(){\n\n\tjQuery.support = {};\n\n\tvar root = document.documentElement,\n\t\tscript = document.createElement(\"script\"),\n\t\tdiv = document.createElement(\"div\"),\n\t\tid = \"script\" + (new Date).getTime();\n\n\tdiv.style.display = \"none\";\n\tdiv.innerHTML = '   <link/><table></table><a href=\"/a\" style=\"color:red;float:left;opacity:.5;\">a</a><select><option>text</option></select><object><param/></object>';\n\n\tvar all = div.getElementsByTagName(\"*\"),\n\t\ta = div.getElementsByTagName(\"a\")[0];\n\n\t// Can't get basic test support\n\tif ( !all || !all.length || !a ) {\n\t\treturn;\n\t}\n\n\tjQuery.support = {\n\t\t// IE strips leading whitespace when .innerHTML is used\n\t\tleadingWhitespace: div.firstChild.nodeType == 3,\n\t\t\n\t\t// Make sure that tbody elements aren't automatically inserted\n\t\t// IE will insert them into empty tables\n\t\ttbody: !div.getElementsByTagName(\"tbody\").length,\n\t\t\n\t\t// Make sure that you can get all elements in an <object> element\n\t\t// IE 7 always returns no results\n\t\tobjectAll: !!div.getElementsByTagName(\"object\")[0]\n\t\t\t.getElementsByTagName(\"*\").length,\n\t\t\n\t\t// Make sure that link elements get serialized correctly by innerHTML\n\t\t// This requires a wrapper element in IE\n\t\thtmlSerialize: !!div.getElementsByTagName(\"link\").length,\n\t\t\n\t\t// Get the style information from getAttribute\n\t\t// (IE uses .cssText insted)\n\t\tstyle: /red/.test( a.getAttribute(\"style\") ),\n\t\t\n\t\t// Make sure that URLs aren't manipulated\n\t\t// (IE normalizes it by default)\n\t\threfNormalized: a.getAttribute(\"href\") === \"/a\",\n\t\t\n\t\t// Make sure that element opacity exists\n\t\t// (IE uses filter instead)\n\t\topacity: a.style.opacity === \"0.5\",\n\t\t\n\t\t// Verify style float existence\n\t\t// (IE uses styleFloat instead of cssFloat)\n\t\tcssFloat: !!a.style.cssFloat,\n\n\t\t// Will be defined later\n\t\tscriptEval: false,\n\t\tnoCloneEvent: true,\n\t\tboxModel: null\n\t};\n\t\n\tscript.type = \"text/javascript\";\n\ttry {\n\t\tscript.appendChild( document.createTextNode( \"window.\" + id + \"=1;\" ) );\n\t} catch(e){}\n\n\troot.insertBefore( script, root.firstChild );\n\t\n\t// Make sure that the execution of code works by injecting a script\n\t// tag with appendChild/createTextNode\n\t// (IE doesn't support this, fails, and uses .text instead)\n\tif ( window[ id ] ) {\n\t\tjQuery.support.scriptEval = true;\n\t\tdelete window[ id ];\n\t}\n\n\troot.removeChild( script );\n\n\tif ( div.attachEvent && div.fireEvent ) {\n\t\tdiv.attachEvent(\"onclick\", function(){\n\t\t\t// Cloning a node shouldn't copy over any\n\t\t\t// bound event handlers (IE does this)\n\t\t\tjQuery.support.noCloneEvent = false;\n\t\t\tdiv.detachEvent(\"onclick\", arguments.callee);\n\t\t});\n\t\tdiv.cloneNode(true).fireEvent(\"onclick\");\n\t}\n\n\t// Figure out if the W3C box model works as expected\n\t// document.body must exist before we can do this\n\tjQuery(function(){\n\t\tvar div = document.createElement(\"div\");\n\t\tdiv.style.width = \"1px\";\n\t\tdiv.style.paddingLeft = \"1px\";\n\n\t\tdocument.body.appendChild( div );\n\t\tjQuery.boxModel = jQuery.support.boxModel = div.offsetWidth === 2;\n\t\tdocument.body.removeChild( div );\n\t});\n})();\n\nvar styleFloat = jQuery.support.cssFloat ? \"cssFloat\" : \"styleFloat\";"},{"path":"./jquery-data/1.3/src/support.js","lines":[1,114],"code":"(function(){\n\n\tjQuery.support = {};\n\n\tvar root = document.documentElement,\n\t\tscript = document.createElement(\"script\"),\n\t\tdiv = document.createElement(\"div\"),\n\t\tid = \"script\" + (new Date).getTime();\n\n\tdiv.style.display = \"none\";\n\tdiv.innerHTML = '   <link/><table></table><a href=\"/a\" style=\"color:red;float:left;opacity:.5;\">a</a><select><option>text</option></select><object><param/></object>';\n\n\tvar all = div.getElementsByTagName(\"*\"),\n\t\ta = div.getElementsByTagName(\"a\")[0];\n\n\t// Can't get basic test support\n\tif ( !all || !all.length || !a ) {\n\t\treturn;\n\t}\n\n\tjQuery.support = {\n\t\t// IE strips leading whitespace when .innerHTML is used\n\t\tleadingWhitespace: div.firstChild.nodeType == 3,\n\t\t\n\t\t// Make sure that tbody elements aren't automatically inserted\n\t\t// IE will insert them into empty tables\n\t\ttbody: !div.getElementsByTagName(\"tbody\").length,\n\t\t\n\t\t// Make sure that you can get all elements in an <object> element\n\t\t// IE 7 always returns no results\n\t\tobjectAll: !!div.getElementsByTagName(\"object\")[0]\n\t\t\t.getElementsByTagName(\"*\").length,\n\t\t\n\t\t// Make sure that link elements get serialized correctly by innerHTML\n\t\t// This requires a wrapper element in IE\n\t\thtmlSerialize: !!div.getElementsByTagName(\"link\").length,\n\t\t\n\t\t// Get the style information from getAttribute\n\t\t// (IE uses .cssText insted)\n\t\tstyle: /red/.test( a.getAttribute(\"style\") ),\n\t\t\n\t\t// Make sure that URLs aren't manipulated\n\t\t// (IE normalizes it by default)\n\t\threfNormalized: a.getAttribute(\"href\") === \"/a\",\n\t\t\n\t\t// Make sure that element opacity exists\n\t\t// (IE uses filter instead)\n\t\topacity: a.style.opacity === \"0.5\",\n\t\t\n\t\t// Verify style float existence\n\t\t// (IE uses styleFloat instead of cssFloat)\n\t\tcssFloat: !!a.style.cssFloat,\n\n\t\t// Will be defined later\n\t\tscriptEval: false,\n\t\tnoCloneEvent: true,\n\t\tboxModel: null\n\t};\n\t\n\tscript.type = \"text/javascript\";\n\ttry {\n\t\tscript.appendChild( document.createTextNode( \"window.\" + id + \"=1;\" ) );\n\t} catch(e){}\n\n\troot.insertBefore( script, root.firstChild );\n\t\n\t// Make sure that the execution of code works by injecting a script\n\t// tag with appendChild/createTextNode\n\t// (IE doesn't support this, fails, and uses .text instead)\n\tif ( window[ id ] ) {\n\t\tjQuery.support.scriptEval = true;\n\t\tdelete window[ id ];\n\t}\n\n\troot.removeChild( script );\n\n\tif ( div.attachEvent && div.fireEvent ) {\n\t\tdiv.attachEvent(\"onclick\", function(){\n\t\t\t// Cloning a node shouldn't copy over any\n\t\t\t// bound event handlers (IE does this)\n\t\t\tjQuery.support.noCloneEvent = false;\n\t\t\tdiv.detachEvent(\"onclick\", arguments.callee);\n\t\t});\n\t\tdiv.cloneNode(true).fireEvent(\"onclick\");\n\t}\n\n\t// Figure out if the W3C box model works as expected\n\t// document.body must exist before we can do this\n\tjQuery(function(){\n\t\tvar div = document.createElement(\"div\");\n\t\tdiv.style.width = \"1px\";\n\t\tdiv.style.paddingLeft = \"1px\";\n\n\t\tdocument.body.appendChild( div );\n\t\tjQuery.boxModel = jQuery.support.boxModel = div.offsetWidth === 2;\n\t\tdocument.body.removeChild( div );\n\t});\n})();\n\nvar styleFloat = jQuery.support.cssFloat ? \"cssFloat\" : \"styleFloat\";"}]}]
