[{"id":"fbdccdd7e17b8a8949e4bd62308cbe0072a62b05","instances":[{"path":"./jquery-data/1.2.6/src/event.js","lines":[92,601],"code":"\t// Detach an event or set of events from an element\n\tremove: function(elem, types, handler) {\n\t\t// don't do events on text and comment nodes\n\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\treturn;\n\n\t\tvar events = jQuery.data(elem, \"events\"), ret, index;\n\n\t\tif ( events ) {\n\t\t\t// Unbind all events for the element\n\t\t\tif ( types == undefined || (typeof types == \"string\" && types.charAt(0) == \".\") )\n\t\t\t\tfor ( var type in events )\n\t\t\t\t\tthis.remove( elem, type + (types || \"\") );\n\t\t\telse {\n\t\t\t\t// types is actually an event object here\n\t\t\t\tif ( types.type ) {\n\t\t\t\t\thandler = types.handler;\n\t\t\t\t\ttypes = types.type;\n\t\t\t\t}\n\n\t\t\t\t// Handle multiple events seperated by a space\n\t\t\t\t// jQuery(...).unbind(\"mouseover mouseout\", fn);\n\t\t\t\tjQuery.each(types.split(/\\s+/), function(index, type){\n\t\t\t\t\t// Namespaced event handlers\n\t\t\t\t\tvar parts = type.split(\".\");\n\t\t\t\t\ttype = parts[0];\n\n\t\t\t\t\tif ( events[type] ) {\n\t\t\t\t\t\t// remove the given handler for the given type\n\t\t\t\t\t\tif ( handler )\n\t\t\t\t\t\t\tdelete events[type][handler.guid];\n\n\t\t\t\t\t\t// remove all handlers for the given type\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfor ( handler in events[type] )\n\t\t\t\t\t\t\t\t// Handle the removal of namespaced events\n\t\t\t\t\t\t\t\tif ( !parts[1] || events[type][handler].type == parts[1] )\n\t\t\t\t\t\t\t\t\tdelete events[type][handler];\n\n\t\t\t\t\t\t// remove generic event handler if no more handlers exist\n\t\t\t\t\t\tfor ( ret in events[type] ) break;\n\t\t\t\t\t\tif ( !ret ) {\n\t\t\t\t\t\t\tif ( !jQuery.event.special[type] || jQuery.event.special[type].teardown.call(elem) === false ) {\n\t\t\t\t\t\t\t\tif (elem.removeEventListener)\n\t\t\t\t\t\t\t\t\telem.removeEventListener(type, jQuery.data(elem, \"handle\"), false);\n\t\t\t\t\t\t\t\telse if (elem.detachEvent)\n\t\t\t\t\t\t\t\t\telem.detachEvent(\"on\" + type, jQuery.data(elem, \"handle\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tret = null;\n\t\t\t\t\t\t\tdelete events[type];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Remove the expando if it's no longer used\n\t\t\tfor ( ret in events ) break;\n\t\t\tif ( !ret ) {\n\t\t\t\tvar handle = jQuery.data( elem, \"handle\" );\n\t\t\t\tif ( handle ) handle.elem = null;\n\t\t\t\tjQuery.removeData( elem, \"events\" );\n\t\t\t\tjQuery.removeData( elem, \"handle\" );\n\t\t\t}\n\t\t}\n\t},\n\n\ttrigger: function(type, data, elem, donative, extra) {\n\t\t// Clone the incoming data, if any\n\t\tdata = jQuery.makeArray(data);\n\n\t\tif ( type.indexOf(\"!\") >= 0 ) {\n\t\t\ttype = type.slice(0, -1);\n\t\t\tvar exclusive = true;\n\t\t}\n\n\t\t// Handle a global trigger\n\t\tif ( !elem ) {\n\t\t\t// Only trigger if we've ever bound an event for it\n\t\t\tif ( this.global[type] )\n\t\t\t\tjQuery(\"*\").add([window, document]).trigger(type, data);\n\n\t\t// Handle triggering a single element\n\t\t} else {\n\t\t\t// don't do events on text and comment nodes\n\t\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\t\treturn undefined;\n\n\t\t\tvar val, ret, fn = jQuery.isFunction( elem[ type ] || null ),\n\t\t\t\t// Check to see if we need to provide a fake event, or not\n\t\t\t\tevent = !data[0] || !data[0].preventDefault;\n\n\t\t\t// Pass along a fake event\n\t\t\tif ( event ) {\n\t\t\t\tdata.unshift({\n\t\t\t\t\ttype: type,\n\t\t\t\t\ttarget: elem,\n\t\t\t\t\tpreventDefault: function(){},\n\t\t\t\t\tstopPropagation: function(){},\n\t\t\t\t\ttimeStamp: now()\n\t\t\t\t});"},{"path":"./jquery-data/1.2.4/src/event.js","lines":[92,601],"code":"\t// Detach an event or set of events from an element\n\tremove: function(elem, types, handler) {\n\t\t// don't do events on text and comment nodes\n\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\treturn;\n\n\t\tvar events = jQuery.data(elem, \"events\"), ret, index;\n\n\t\tif ( events ) {\n\t\t\t// Unbind all events for the element\n\t\t\tif ( types == undefined || (typeof types == \"string\" && types.charAt(0) == \".\") )\n\t\t\t\tfor ( var type in events )\n\t\t\t\t\tthis.remove( elem, type + (types || \"\") );\n\t\t\telse {\n\t\t\t\t// types is actually an event object here\n\t\t\t\tif ( types.type ) {\n\t\t\t\t\thandler = types.handler;\n\t\t\t\t\ttypes = types.type;\n\t\t\t\t}\n\n\t\t\t\t// Handle multiple events seperated by a space\n\t\t\t\t// jQuery(...).unbind(\"mouseover mouseout\", fn);\n\t\t\t\tjQuery.each(types.split(/\\s+/), function(index, type){\n\t\t\t\t\t// Namespaced event handlers\n\t\t\t\t\tvar parts = type.split(\".\");\n\t\t\t\t\ttype = parts[0];\n\n\t\t\t\t\tif ( events[type] ) {\n\t\t\t\t\t\t// remove the given handler for the given type\n\t\t\t\t\t\tif ( handler )\n\t\t\t\t\t\t\tdelete events[type][handler.guid];\n\n\t\t\t\t\t\t// remove all handlers for the given type\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfor ( handler in events[type] )\n\t\t\t\t\t\t\t\t// Handle the removal of namespaced events\n\t\t\t\t\t\t\t\tif ( !parts[1] || events[type][handler].type == parts[1] )\n\t\t\t\t\t\t\t\t\tdelete events[type][handler];\n\n\t\t\t\t\t\t// remove generic event handler if no more handlers exist\n\t\t\t\t\t\tfor ( ret in events[type] ) break;\n\t\t\t\t\t\tif ( !ret ) {\n\t\t\t\t\t\t\tif ( !jQuery.event.special[type] || jQuery.event.special[type].teardown.call(elem) === false ) {\n\t\t\t\t\t\t\t\tif (elem.removeEventListener)\n\t\t\t\t\t\t\t\t\telem.removeEventListener(type, jQuery.data(elem, \"handle\"), false);\n\t\t\t\t\t\t\t\telse if (elem.detachEvent)\n\t\t\t\t\t\t\t\t\telem.detachEvent(\"on\" + type, jQuery.data(elem, \"handle\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tret = null;\n\t\t\t\t\t\t\tdelete events[type];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Remove the expando if it's no longer used\n\t\t\tfor ( ret in events ) break;\n\t\t\tif ( !ret ) {\n\t\t\t\tvar handle = jQuery.data( elem, \"handle\" );\n\t\t\t\tif ( handle ) handle.elem = null;\n\t\t\t\tjQuery.removeData( elem, \"events\" );\n\t\t\t\tjQuery.removeData( elem, \"handle\" );\n\t\t\t}\n\t\t}\n\t},\n\n\ttrigger: function(type, data, elem, donative, extra) {\n\t\t// Clone the incoming data, if any\n\t\tdata = jQuery.makeArray(data);\n\n\t\tif ( type.indexOf(\"!\") >= 0 ) {\n\t\t\ttype = type.slice(0, -1);\n\t\t\tvar exclusive = true;\n\t\t}\n\n\t\t// Handle a global trigger\n\t\tif ( !elem ) {\n\t\t\t// Only trigger if we've ever bound an event for it\n\t\t\tif ( this.global[type] )\n\t\t\t\tjQuery(\"*\").add([window, document]).trigger(type, data);\n\n\t\t// Handle triggering a single element\n\t\t} else {\n\t\t\t// don't do events on text and comment nodes\n\t\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\t\treturn undefined;\n\n\t\t\tvar val, ret, fn = jQuery.isFunction( elem[ type ] || null ),\n\t\t\t\t// Check to see if we need to provide a fake event, or not\n\t\t\t\tevent = !data[0] || !data[0].preventDefault;\n\n\t\t\t// Pass along a fake event\n\t\t\tif ( event ) {\n\t\t\t\tdata.unshift({\n\t\t\t\t\ttype: type,\n\t\t\t\t\ttarget: elem,\n\t\t\t\t\tpreventDefault: function(){},\n\t\t\t\t\tstopPropagation: function(){},\n\t\t\t\t\ttimeStamp: now()\n\t\t\t\t});"}]},
{"id":"fbdccdd7e17b8a8949e4bd62308cbe0072a62b05","instances":[{"path":"./jquery-data/1.2.6/src/event.js","lines":[92,601],"code":"\t// Detach an event or set of events from an element\n\tremove: function(elem, types, handler) {\n\t\t// don't do events on text and comment nodes\n\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\treturn;\n\n\t\tvar events = jQuery.data(elem, \"events\"), ret, index;\n\n\t\tif ( events ) {\n\t\t\t// Unbind all events for the element\n\t\t\tif ( types == undefined || (typeof types == \"string\" && types.charAt(0) == \".\") )\n\t\t\t\tfor ( var type in events )\n\t\t\t\t\tthis.remove( elem, type + (types || \"\") );\n\t\t\telse {\n\t\t\t\t// types is actually an event object here\n\t\t\t\tif ( types.type ) {\n\t\t\t\t\thandler = types.handler;\n\t\t\t\t\ttypes = types.type;\n\t\t\t\t}\n\n\t\t\t\t// Handle multiple events seperated by a space\n\t\t\t\t// jQuery(...).unbind(\"mouseover mouseout\", fn);\n\t\t\t\tjQuery.each(types.split(/\\s+/), function(index, type){\n\t\t\t\t\t// Namespaced event handlers\n\t\t\t\t\tvar parts = type.split(\".\");\n\t\t\t\t\ttype = parts[0];\n\n\t\t\t\t\tif ( events[type] ) {\n\t\t\t\t\t\t// remove the given handler for the given type\n\t\t\t\t\t\tif ( handler )\n\t\t\t\t\t\t\tdelete events[type][handler.guid];\n\n\t\t\t\t\t\t// remove all handlers for the given type\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfor ( handler in events[type] )\n\t\t\t\t\t\t\t\t// Handle the removal of namespaced events\n\t\t\t\t\t\t\t\tif ( !parts[1] || events[type][handler].type == parts[1] )\n\t\t\t\t\t\t\t\t\tdelete events[type][handler];\n\n\t\t\t\t\t\t// remove generic event handler if no more handlers exist\n\t\t\t\t\t\tfor ( ret in events[type] ) break;\n\t\t\t\t\t\tif ( !ret ) {\n\t\t\t\t\t\t\tif ( !jQuery.event.special[type] || jQuery.event.special[type].teardown.call(elem) === false ) {\n\t\t\t\t\t\t\t\tif (elem.removeEventListener)\n\t\t\t\t\t\t\t\t\telem.removeEventListener(type, jQuery.data(elem, \"handle\"), false);\n\t\t\t\t\t\t\t\telse if (elem.detachEvent)\n\t\t\t\t\t\t\t\t\telem.detachEvent(\"on\" + type, jQuery.data(elem, \"handle\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tret = null;\n\t\t\t\t\t\t\tdelete events[type];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Remove the expando if it's no longer used\n\t\t\tfor ( ret in events ) break;\n\t\t\tif ( !ret ) {\n\t\t\t\tvar handle = jQuery.data( elem, \"handle\" );\n\t\t\t\tif ( handle ) handle.elem = null;\n\t\t\t\tjQuery.removeData( elem, \"events\" );\n\t\t\t\tjQuery.removeData( elem, \"handle\" );\n\t\t\t}\n\t\t}\n\t},\n\n\ttrigger: function(type, data, elem, donative, extra) {\n\t\t// Clone the incoming data, if any\n\t\tdata = jQuery.makeArray(data);\n\n\t\tif ( type.indexOf(\"!\") >= 0 ) {\n\t\t\ttype = type.slice(0, -1);\n\t\t\tvar exclusive = true;\n\t\t}\n\n\t\t// Handle a global trigger\n\t\tif ( !elem ) {\n\t\t\t// Only trigger if we've ever bound an event for it\n\t\t\tif ( this.global[type] )\n\t\t\t\tjQuery(\"*\").add([window, document]).trigger(type, data);\n\n\t\t// Handle triggering a single element\n\t\t} else {\n\t\t\t// don't do events on text and comment nodes\n\t\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\t\treturn undefined;\n\n\t\t\tvar val, ret, fn = jQuery.isFunction( elem[ type ] || null ),\n\t\t\t\t// Check to see if we need to provide a fake event, or not\n\t\t\t\tevent = !data[0] || !data[0].preventDefault;\n\n\t\t\t// Pass along a fake event\n\t\t\tif ( event ) {\n\t\t\t\tdata.unshift({\n\t\t\t\t\ttype: type,\n\t\t\t\t\ttarget: elem,\n\t\t\t\t\tpreventDefault: function(){},\n\t\t\t\t\tstopPropagation: function(){},\n\t\t\t\t\ttimeStamp: now()\n\t\t\t\t});"},{"path":"./jquery-data/1.2.4/src/event.js","lines":[92,601],"code":"\t// Detach an event or set of events from an element\n\tremove: function(elem, types, handler) {\n\t\t// don't do events on text and comment nodes\n\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\treturn;\n\n\t\tvar events = jQuery.data(elem, \"events\"), ret, index;\n\n\t\tif ( events ) {\n\t\t\t// Unbind all events for the element\n\t\t\tif ( types == undefined || (typeof types == \"string\" && types.charAt(0) == \".\") )\n\t\t\t\tfor ( var type in events )\n\t\t\t\t\tthis.remove( elem, type + (types || \"\") );\n\t\t\telse {\n\t\t\t\t// types is actually an event object here\n\t\t\t\tif ( types.type ) {\n\t\t\t\t\thandler = types.handler;\n\t\t\t\t\ttypes = types.type;\n\t\t\t\t}\n\n\t\t\t\t// Handle multiple events seperated by a space\n\t\t\t\t// jQuery(...).unbind(\"mouseover mouseout\", fn);\n\t\t\t\tjQuery.each(types.split(/\\s+/), function(index, type){\n\t\t\t\t\t// Namespaced event handlers\n\t\t\t\t\tvar parts = type.split(\".\");\n\t\t\t\t\ttype = parts[0];\n\n\t\t\t\t\tif ( events[type] ) {\n\t\t\t\t\t\t// remove the given handler for the given type\n\t\t\t\t\t\tif ( handler )\n\t\t\t\t\t\t\tdelete events[type][handler.guid];\n\n\t\t\t\t\t\t// remove all handlers for the given type\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfor ( handler in events[type] )\n\t\t\t\t\t\t\t\t// Handle the removal of namespaced events\n\t\t\t\t\t\t\t\tif ( !parts[1] || events[type][handler].type == parts[1] )\n\t\t\t\t\t\t\t\t\tdelete events[type][handler];\n\n\t\t\t\t\t\t// remove generic event handler if no more handlers exist\n\t\t\t\t\t\tfor ( ret in events[type] ) break;\n\t\t\t\t\t\tif ( !ret ) {\n\t\t\t\t\t\t\tif ( !jQuery.event.special[type] || jQuery.event.special[type].teardown.call(elem) === false ) {\n\t\t\t\t\t\t\t\tif (elem.removeEventListener)\n\t\t\t\t\t\t\t\t\telem.removeEventListener(type, jQuery.data(elem, \"handle\"), false);\n\t\t\t\t\t\t\t\telse if (elem.detachEvent)\n\t\t\t\t\t\t\t\t\telem.detachEvent(\"on\" + type, jQuery.data(elem, \"handle\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tret = null;\n\t\t\t\t\t\t\tdelete events[type];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Remove the expando if it's no longer used\n\t\t\tfor ( ret in events ) break;\n\t\t\tif ( !ret ) {\n\t\t\t\tvar handle = jQuery.data( elem, \"handle\" );\n\t\t\t\tif ( handle ) handle.elem = null;\n\t\t\t\tjQuery.removeData( elem, \"events\" );\n\t\t\t\tjQuery.removeData( elem, \"handle\" );\n\t\t\t}\n\t\t}\n\t},\n\n\ttrigger: function(type, data, elem, donative, extra) {\n\t\t// Clone the incoming data, if any\n\t\tdata = jQuery.makeArray(data);\n\n\t\tif ( type.indexOf(\"!\") >= 0 ) {\n\t\t\ttype = type.slice(0, -1);\n\t\t\tvar exclusive = true;\n\t\t}\n\n\t\t// Handle a global trigger\n\t\tif ( !elem ) {\n\t\t\t// Only trigger if we've ever bound an event for it\n\t\t\tif ( this.global[type] )\n\t\t\t\tjQuery(\"*\").add([window, document]).trigger(type, data);\n\n\t\t// Handle triggering a single element\n\t\t} else {\n\t\t\t// don't do events on text and comment nodes\n\t\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\t\treturn undefined;\n\n\t\t\tvar val, ret, fn = jQuery.isFunction( elem[ type ] || null ),\n\t\t\t\t// Check to see if we need to provide a fake event, or not\n\t\t\t\tevent = !data[0] || !data[0].preventDefault;\n\n\t\t\t// Pass along a fake event\n\t\t\tif ( event ) {\n\t\t\t\tdata.unshift({\n\t\t\t\t\ttype: type,\n\t\t\t\t\ttarget: elem,\n\t\t\t\t\tpreventDefault: function(){},\n\t\t\t\t\tstopPropagation: function(){},\n\t\t\t\t\ttimeStamp: now()\n\t\t\t\t});"}]},
{"id":"fbdccdd7e17b8a8949e4bd62308cbe0072a62b05","instances":[{"path":"./jquery-data/1.2.6/src/event.js","lines":[92,601],"code":"\t// Detach an event or set of events from an element\n\tremove: function(elem, types, handler) {\n\t\t// don't do events on text and comment nodes\n\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\treturn;\n\n\t\tvar events = jQuery.data(elem, \"events\"), ret, index;\n\n\t\tif ( events ) {\n\t\t\t// Unbind all events for the element\n\t\t\tif ( types == undefined || (typeof types == \"string\" && types.charAt(0) == \".\") )\n\t\t\t\tfor ( var type in events )\n\t\t\t\t\tthis.remove( elem, type + (types || \"\") );\n\t\t\telse {\n\t\t\t\t// types is actually an event object here\n\t\t\t\tif ( types.type ) {\n\t\t\t\t\thandler = types.handler;\n\t\t\t\t\ttypes = types.type;\n\t\t\t\t}\n\n\t\t\t\t// Handle multiple events seperated by a space\n\t\t\t\t// jQuery(...).unbind(\"mouseover mouseout\", fn);\n\t\t\t\tjQuery.each(types.split(/\\s+/), function(index, type){\n\t\t\t\t\t// Namespaced event handlers\n\t\t\t\t\tvar parts = type.split(\".\");\n\t\t\t\t\ttype = parts[0];\n\n\t\t\t\t\tif ( events[type] ) {\n\t\t\t\t\t\t// remove the given handler for the given type\n\t\t\t\t\t\tif ( handler )\n\t\t\t\t\t\t\tdelete events[type][handler.guid];\n\n\t\t\t\t\t\t// remove all handlers for the given type\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfor ( handler in events[type] )\n\t\t\t\t\t\t\t\t// Handle the removal of namespaced events\n\t\t\t\t\t\t\t\tif ( !parts[1] || events[type][handler].type == parts[1] )\n\t\t\t\t\t\t\t\t\tdelete events[type][handler];\n\n\t\t\t\t\t\t// remove generic event handler if no more handlers exist\n\t\t\t\t\t\tfor ( ret in events[type] ) break;\n\t\t\t\t\t\tif ( !ret ) {\n\t\t\t\t\t\t\tif ( !jQuery.event.special[type] || jQuery.event.special[type].teardown.call(elem) === false ) {\n\t\t\t\t\t\t\t\tif (elem.removeEventListener)\n\t\t\t\t\t\t\t\t\telem.removeEventListener(type, jQuery.data(elem, \"handle\"), false);\n\t\t\t\t\t\t\t\telse if (elem.detachEvent)\n\t\t\t\t\t\t\t\t\telem.detachEvent(\"on\" + type, jQuery.data(elem, \"handle\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tret = null;\n\t\t\t\t\t\t\tdelete events[type];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Remove the expando if it's no longer used\n\t\t\tfor ( ret in events ) break;\n\t\t\tif ( !ret ) {\n\t\t\t\tvar handle = jQuery.data( elem, \"handle\" );\n\t\t\t\tif ( handle ) handle.elem = null;\n\t\t\t\tjQuery.removeData( elem, \"events\" );\n\t\t\t\tjQuery.removeData( elem, \"handle\" );\n\t\t\t}\n\t\t}\n\t},\n\n\ttrigger: function(type, data, elem, donative, extra) {\n\t\t// Clone the incoming data, if any\n\t\tdata = jQuery.makeArray(data);\n\n\t\tif ( type.indexOf(\"!\") >= 0 ) {\n\t\t\ttype = type.slice(0, -1);\n\t\t\tvar exclusive = true;\n\t\t}\n\n\t\t// Handle a global trigger\n\t\tif ( !elem ) {\n\t\t\t// Only trigger if we've ever bound an event for it\n\t\t\tif ( this.global[type] )\n\t\t\t\tjQuery(\"*\").add([window, document]).trigger(type, data);\n\n\t\t// Handle triggering a single element\n\t\t} else {\n\t\t\t// don't do events on text and comment nodes\n\t\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\t\treturn undefined;\n\n\t\t\tvar val, ret, fn = jQuery.isFunction( elem[ type ] || null ),\n\t\t\t\t// Check to see if we need to provide a fake event, or not\n\t\t\t\tevent = !data[0] || !data[0].preventDefault;\n\n\t\t\t// Pass along a fake event\n\t\t\tif ( event ) {\n\t\t\t\tdata.unshift({\n\t\t\t\t\ttype: type,\n\t\t\t\t\ttarget: elem,\n\t\t\t\t\tpreventDefault: function(){},\n\t\t\t\t\tstopPropagation: function(){},\n\t\t\t\t\ttimeStamp: now()\n\t\t\t\t});"},{"path":"./jquery-data/1.2.4/src/event.js","lines":[92,601],"code":"\t// Detach an event or set of events from an element\n\tremove: function(elem, types, handler) {\n\t\t// don't do events on text and comment nodes\n\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\treturn;\n\n\t\tvar events = jQuery.data(elem, \"events\"), ret, index;\n\n\t\tif ( events ) {\n\t\t\t// Unbind all events for the element\n\t\t\tif ( types == undefined || (typeof types == \"string\" && types.charAt(0) == \".\") )\n\t\t\t\tfor ( var type in events )\n\t\t\t\t\tthis.remove( elem, type + (types || \"\") );\n\t\t\telse {\n\t\t\t\t// types is actually an event object here\n\t\t\t\tif ( types.type ) {\n\t\t\t\t\thandler = types.handler;\n\t\t\t\t\ttypes = types.type;\n\t\t\t\t}\n\n\t\t\t\t// Handle multiple events seperated by a space\n\t\t\t\t// jQuery(...).unbind(\"mouseover mouseout\", fn);\n\t\t\t\tjQuery.each(types.split(/\\s+/), function(index, type){\n\t\t\t\t\t// Namespaced event handlers\n\t\t\t\t\tvar parts = type.split(\".\");\n\t\t\t\t\ttype = parts[0];\n\n\t\t\t\t\tif ( events[type] ) {\n\t\t\t\t\t\t// remove the given handler for the given type\n\t\t\t\t\t\tif ( handler )\n\t\t\t\t\t\t\tdelete events[type][handler.guid];\n\n\t\t\t\t\t\t// remove all handlers for the given type\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfor ( handler in events[type] )\n\t\t\t\t\t\t\t\t// Handle the removal of namespaced events\n\t\t\t\t\t\t\t\tif ( !parts[1] || events[type][handler].type == parts[1] )\n\t\t\t\t\t\t\t\t\tdelete events[type][handler];\n\n\t\t\t\t\t\t// remove generic event handler if no more handlers exist\n\t\t\t\t\t\tfor ( ret in events[type] ) break;\n\t\t\t\t\t\tif ( !ret ) {\n\t\t\t\t\t\t\tif ( !jQuery.event.special[type] || jQuery.event.special[type].teardown.call(elem) === false ) {\n\t\t\t\t\t\t\t\tif (elem.removeEventListener)\n\t\t\t\t\t\t\t\t\telem.removeEventListener(type, jQuery.data(elem, \"handle\"), false);\n\t\t\t\t\t\t\t\telse if (elem.detachEvent)\n\t\t\t\t\t\t\t\t\telem.detachEvent(\"on\" + type, jQuery.data(elem, \"handle\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tret = null;\n\t\t\t\t\t\t\tdelete events[type];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Remove the expando if it's no longer used\n\t\t\tfor ( ret in events ) break;\n\t\t\tif ( !ret ) {\n\t\t\t\tvar handle = jQuery.data( elem, \"handle\" );\n\t\t\t\tif ( handle ) handle.elem = null;\n\t\t\t\tjQuery.removeData( elem, \"events\" );\n\t\t\t\tjQuery.removeData( elem, \"handle\" );\n\t\t\t}\n\t\t}\n\t},\n\n\ttrigger: function(type, data, elem, donative, extra) {\n\t\t// Clone the incoming data, if any\n\t\tdata = jQuery.makeArray(data);\n\n\t\tif ( type.indexOf(\"!\") >= 0 ) {\n\t\t\ttype = type.slice(0, -1);\n\t\t\tvar exclusive = true;\n\t\t}\n\n\t\t// Handle a global trigger\n\t\tif ( !elem ) {\n\t\t\t// Only trigger if we've ever bound an event for it\n\t\t\tif ( this.global[type] )\n\t\t\t\tjQuery(\"*\").add([window, document]).trigger(type, data);\n\n\t\t// Handle triggering a single element\n\t\t} else {\n\t\t\t// don't do events on text and comment nodes\n\t\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\t\treturn undefined;\n\n\t\t\tvar val, ret, fn = jQuery.isFunction( elem[ type ] || null ),\n\t\t\t\t// Check to see if we need to provide a fake event, or not\n\t\t\t\tevent = !data[0] || !data[0].preventDefault;\n\n\t\t\t// Pass along a fake event\n\t\t\tif ( event ) {\n\t\t\t\tdata.unshift({\n\t\t\t\t\ttype: type,\n\t\t\t\t\ttarget: elem,\n\t\t\t\t\tpreventDefault: function(){},\n\t\t\t\t\tstopPropagation: function(){},\n\t\t\t\t\ttimeStamp: now()\n\t\t\t\t});"}]},
{"id":"fbdccdd7e17b8a8949e4bd62308cbe0072a62b05","instances":[{"path":"./jquery-data/1.2.6/src/event.js","lines":[92,601],"code":"\t// Detach an event or set of events from an element\n\tremove: function(elem, types, handler) {\n\t\t// don't do events on text and comment nodes\n\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\treturn;\n\n\t\tvar events = jQuery.data(elem, \"events\"), ret, index;\n\n\t\tif ( events ) {\n\t\t\t// Unbind all events for the element\n\t\t\tif ( types == undefined || (typeof types == \"string\" && types.charAt(0) == \".\") )\n\t\t\t\tfor ( var type in events )\n\t\t\t\t\tthis.remove( elem, type + (types || \"\") );\n\t\t\telse {\n\t\t\t\t// types is actually an event object here\n\t\t\t\tif ( types.type ) {\n\t\t\t\t\thandler = types.handler;\n\t\t\t\t\ttypes = types.type;\n\t\t\t\t}\n\n\t\t\t\t// Handle multiple events seperated by a space\n\t\t\t\t// jQuery(...).unbind(\"mouseover mouseout\", fn);\n\t\t\t\tjQuery.each(types.split(/\\s+/), function(index, type){\n\t\t\t\t\t// Namespaced event handlers\n\t\t\t\t\tvar parts = type.split(\".\");\n\t\t\t\t\ttype = parts[0];\n\n\t\t\t\t\tif ( events[type] ) {\n\t\t\t\t\t\t// remove the given handler for the given type\n\t\t\t\t\t\tif ( handler )\n\t\t\t\t\t\t\tdelete events[type][handler.guid];\n\n\t\t\t\t\t\t// remove all handlers for the given type\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfor ( handler in events[type] )\n\t\t\t\t\t\t\t\t// Handle the removal of namespaced events\n\t\t\t\t\t\t\t\tif ( !parts[1] || events[type][handler].type == parts[1] )\n\t\t\t\t\t\t\t\t\tdelete events[type][handler];\n\n\t\t\t\t\t\t// remove generic event handler if no more handlers exist\n\t\t\t\t\t\tfor ( ret in events[type] ) break;\n\t\t\t\t\t\tif ( !ret ) {\n\t\t\t\t\t\t\tif ( !jQuery.event.special[type] || jQuery.event.special[type].teardown.call(elem) === false ) {\n\t\t\t\t\t\t\t\tif (elem.removeEventListener)\n\t\t\t\t\t\t\t\t\telem.removeEventListener(type, jQuery.data(elem, \"handle\"), false);\n\t\t\t\t\t\t\t\telse if (elem.detachEvent)\n\t\t\t\t\t\t\t\t\telem.detachEvent(\"on\" + type, jQuery.data(elem, \"handle\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tret = null;\n\t\t\t\t\t\t\tdelete events[type];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Remove the expando if it's no longer used\n\t\t\tfor ( ret in events ) break;\n\t\t\tif ( !ret ) {\n\t\t\t\tvar handle = jQuery.data( elem, \"handle\" );\n\t\t\t\tif ( handle ) handle.elem = null;\n\t\t\t\tjQuery.removeData( elem, \"events\" );\n\t\t\t\tjQuery.removeData( elem, \"handle\" );\n\t\t\t}\n\t\t}\n\t},\n\n\ttrigger: function(type, data, elem, donative, extra) {\n\t\t// Clone the incoming data, if any\n\t\tdata = jQuery.makeArray(data);\n\n\t\tif ( type.indexOf(\"!\") >= 0 ) {\n\t\t\ttype = type.slice(0, -1);\n\t\t\tvar exclusive = true;\n\t\t}\n\n\t\t// Handle a global trigger\n\t\tif ( !elem ) {\n\t\t\t// Only trigger if we've ever bound an event for it\n\t\t\tif ( this.global[type] )\n\t\t\t\tjQuery(\"*\").add([window, document]).trigger(type, data);\n\n\t\t// Handle triggering a single element\n\t\t} else {\n\t\t\t// don't do events on text and comment nodes\n\t\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\t\treturn undefined;\n\n\t\t\tvar val, ret, fn = jQuery.isFunction( elem[ type ] || null ),\n\t\t\t\t// Check to see if we need to provide a fake event, or not\n\t\t\t\tevent = !data[0] || !data[0].preventDefault;\n\n\t\t\t// Pass along a fake event\n\t\t\tif ( event ) {\n\t\t\t\tdata.unshift({\n\t\t\t\t\ttype: type,\n\t\t\t\t\ttarget: elem,\n\t\t\t\t\tpreventDefault: function(){},\n\t\t\t\t\tstopPropagation: function(){},\n\t\t\t\t\ttimeStamp: now()\n\t\t\t\t});"},{"path":"./jquery-data/1.2.4/src/event.js","lines":[92,601],"code":"\t// Detach an event or set of events from an element\n\tremove: function(elem, types, handler) {\n\t\t// don't do events on text and comment nodes\n\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\treturn;\n\n\t\tvar events = jQuery.data(elem, \"events\"), ret, index;\n\n\t\tif ( events ) {\n\t\t\t// Unbind all events for the element\n\t\t\tif ( types == undefined || (typeof types == \"string\" && types.charAt(0) == \".\") )\n\t\t\t\tfor ( var type in events )\n\t\t\t\t\tthis.remove( elem, type + (types || \"\") );\n\t\t\telse {\n\t\t\t\t// types is actually an event object here\n\t\t\t\tif ( types.type ) {\n\t\t\t\t\thandler = types.handler;\n\t\t\t\t\ttypes = types.type;\n\t\t\t\t}\n\n\t\t\t\t// Handle multiple events seperated by a space\n\t\t\t\t// jQuery(...).unbind(\"mouseover mouseout\", fn);\n\t\t\t\tjQuery.each(types.split(/\\s+/), function(index, type){\n\t\t\t\t\t// Namespaced event handlers\n\t\t\t\t\tvar parts = type.split(\".\");\n\t\t\t\t\ttype = parts[0];\n\n\t\t\t\t\tif ( events[type] ) {\n\t\t\t\t\t\t// remove the given handler for the given type\n\t\t\t\t\t\tif ( handler )\n\t\t\t\t\t\t\tdelete events[type][handler.guid];\n\n\t\t\t\t\t\t// remove all handlers for the given type\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfor ( handler in events[type] )\n\t\t\t\t\t\t\t\t// Handle the removal of namespaced events\n\t\t\t\t\t\t\t\tif ( !parts[1] || events[type][handler].type == parts[1] )\n\t\t\t\t\t\t\t\t\tdelete events[type][handler];\n\n\t\t\t\t\t\t// remove generic event handler if no more handlers exist\n\t\t\t\t\t\tfor ( ret in events[type] ) break;\n\t\t\t\t\t\tif ( !ret ) {\n\t\t\t\t\t\t\tif ( !jQuery.event.special[type] || jQuery.event.special[type].teardown.call(elem) === false ) {\n\t\t\t\t\t\t\t\tif (elem.removeEventListener)\n\t\t\t\t\t\t\t\t\telem.removeEventListener(type, jQuery.data(elem, \"handle\"), false);\n\t\t\t\t\t\t\t\telse if (elem.detachEvent)\n\t\t\t\t\t\t\t\t\telem.detachEvent(\"on\" + type, jQuery.data(elem, \"handle\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tret = null;\n\t\t\t\t\t\t\tdelete events[type];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Remove the expando if it's no longer used\n\t\t\tfor ( ret in events ) break;\n\t\t\tif ( !ret ) {\n\t\t\t\tvar handle = jQuery.data( elem, \"handle\" );\n\t\t\t\tif ( handle ) handle.elem = null;\n\t\t\t\tjQuery.removeData( elem, \"events\" );\n\t\t\t\tjQuery.removeData( elem, \"handle\" );\n\t\t\t}\n\t\t}\n\t},\n\n\ttrigger: function(type, data, elem, donative, extra) {\n\t\t// Clone the incoming data, if any\n\t\tdata = jQuery.makeArray(data);\n\n\t\tif ( type.indexOf(\"!\") >= 0 ) {\n\t\t\ttype = type.slice(0, -1);\n\t\t\tvar exclusive = true;\n\t\t}\n\n\t\t// Handle a global trigger\n\t\tif ( !elem ) {\n\t\t\t// Only trigger if we've ever bound an event for it\n\t\t\tif ( this.global[type] )\n\t\t\t\tjQuery(\"*\").add([window, document]).trigger(type, data);\n\n\t\t// Handle triggering a single element\n\t\t} else {\n\t\t\t// don't do events on text and comment nodes\n\t\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\t\treturn undefined;\n\n\t\t\tvar val, ret, fn = jQuery.isFunction( elem[ type ] || null ),\n\t\t\t\t// Check to see if we need to provide a fake event, or not\n\t\t\t\tevent = !data[0] || !data[0].preventDefault;\n\n\t\t\t// Pass along a fake event\n\t\t\tif ( event ) {\n\t\t\t\tdata.unshift({\n\t\t\t\t\ttype: type,\n\t\t\t\t\ttarget: elem,\n\t\t\t\t\tpreventDefault: function(){},\n\t\t\t\t\tstopPropagation: function(){},\n\t\t\t\t\ttimeStamp: now()\n\t\t\t\t});"}]},
{"id":"7b945c07043f5ae4eece937c8ebd16dc792f7910","instances":[{"path":"./jquery-data/1.2.6/src/event.js","lines":[1,129],"code":"/*\n * A number of helper functions used for managing events.\n * Many of the ideas behind this code orignated from\n * Dean Edwards' addEvent library.\n */\njQuery.event = {\n\n\t// Bind an event to an element\n\t// Original by Dean Edwards\n\tadd: function(elem, types, handler, data) {\n\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\treturn;\n\n\t\t// For whatever reason, IE has trouble passing the window object\n\t\t// around, causing it to be cloned in the process\n\t\tif ( jQuery.browser.msie && elem.setInterval )\n\t\t\telem = window;\n\n\t\t// Make sure that the function being executed has a unique ID\n\t\tif ( !handler.guid )\n\t\t\thandler.guid = this.guid++;\n\n\t\t// if data is passed, bind to handler\n\t\tif( data != undefined ) {\n\t\t\t// Create temporary function pointer to original handler\n\t\t\tvar fn = handler;\n\n\t\t\t// Create unique handler function, wrapped around original handler\n\t\t\thandler = this.proxy( fn, function() {\n\t\t\t\t// Pass arguments and context to original handler\n\t\t\t\treturn fn.apply(this, arguments);\n\t\t\t});\n\n\t\t\t// Store data in unique handler\n\t\t\thandler.data = data;\n\t\t}\n\n\t\t// Init the element's event structure\n\t\tvar events = jQuery.data(elem, \"events\") || jQuery.data(elem, \"events\", {}),\n\t\t\thandle = jQuery.data(elem, \"handle\") || jQuery.data(elem, \"handle\", function(){\n\t\t\t\t// Handle the second event of a trigger and when\n\t\t\t\t// an event is called after a page has unloaded\n\t\t\t\tif ( typeof jQuery != \"undefined\" && !jQuery.event.triggered )\n\t\t\t\t\treturn jQuery.event.handle.apply(arguments.callee.elem, arguments);\n\t\t\t});\n\t\t// Add elem as a property of the handle function\n\t\t// This is to prevent a memory leak with non-native\n\t\t// event in IE.\n\t\thandle.elem = elem;\n\n\t\t// Handle multiple events separated by a space\n\t\t// jQuery(...).bind(\"mouseover mouseout\", fn);\n\t\tjQuery.each(types.split(/\\s+/), function(index, type) {\n\t\t\t// Namespaced event handlers\n\t\t\tvar parts = type.split(\".\");\n\t\t\ttype = parts[0];\n\t\t\thandler.type = parts[1];\n\n\t\t\t// Get the current list of functions bound to this event\n\t\t\tvar handlers = events[type];\n\n\t\t\t// Init the event handler queue\n\t\t\tif (!handlers) {\n\t\t\t\thandlers = events[type] = {};\n\n\t\t\t\t// Check for a special event handler\n\t\t\t\t// Only use addEventListener/attachEvent if the special\n\t\t\t\t// events handler returns false\n\t\t\t\tif ( !jQuery.event.special[type] || jQuery.event.special[type].setup.call(elem) === false ) {\n\t\t\t\t\t// Bind the global event handler to the element\n\t\t\t\t\tif (elem.addEventListener)\n\t\t\t\t\t\telem.addEventListener(type, handle, false);\n\t\t\t\t\telse if (elem.attachEvent)\n\t\t\t\t\t\telem.attachEvent(\"on\" + type, handle);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add the function to the element's handler list\n\t\t\thandlers[handler.guid] = handler;\n\n\t\t\t// Keep track of which events have been used, for global triggering\n\t\t\tjQuery.event.global[type] = true;\n\t\t});\n\n\t\t// Nullify elem to prevent memory leaks in IE\n\t\telem = null;\n\t},\n\n\tguid: 1,\n\tglobal: {},\n\n\t// Detach an event or set of events from an element\n\tremove: function(elem, types, handler) {\n\t\t// don't do events on text and comment nodes\n\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\treturn;\n\n\t\tvar events = jQuery.data(elem, \"events\"), ret, index;\n\n\t\tif ( events ) {"},{"path":"./jquery-data/1.2.4/src/event.js","lines":[1,129],"code":"/*\n * A number of helper functions used for managing events.\n * Many of the ideas behind this code orignated from\n * Dean Edwards' addEvent library.\n */\njQuery.event = {\n\n\t// Bind an event to an element\n\t// Original by Dean Edwards\n\tadd: function(elem, types, handler, data) {\n\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\treturn;\n\n\t\t// For whatever reason, IE has trouble passing the window object\n\t\t// around, causing it to be cloned in the process\n\t\tif ( jQuery.browser.msie && elem.setInterval )\n\t\t\telem = window;\n\n\t\t// Make sure that the function being executed has a unique ID\n\t\tif ( !handler.guid )\n\t\t\thandler.guid = this.guid++;\n\n\t\t// if data is passed, bind to handler\n\t\tif( data != undefined ) {\n\t\t\t// Create temporary function pointer to original handler\n\t\t\tvar fn = handler;\n\n\t\t\t// Create unique handler function, wrapped around original handler\n\t\t\thandler = this.proxy( fn, function() {\n\t\t\t\t// Pass arguments and context to original handler\n\t\t\t\treturn fn.apply(this, arguments);\n\t\t\t});\n\n\t\t\t// Store data in unique handler\n\t\t\thandler.data = data;\n\t\t}\n\n\t\t// Init the element's event structure\n\t\tvar events = jQuery.data(elem, \"events\") || jQuery.data(elem, \"events\", {}),\n\t\t\thandle = jQuery.data(elem, \"handle\") || jQuery.data(elem, \"handle\", function(){\n\t\t\t\t// Handle the second event of a trigger and when\n\t\t\t\t// an event is called after a page has unloaded\n\t\t\t\tif ( typeof jQuery != \"undefined\" && !jQuery.event.triggered )\n\t\t\t\t\treturn jQuery.event.handle.apply(arguments.callee.elem, arguments);\n\t\t\t});\n\t\t// Add elem as a property of the handle function\n\t\t// This is to prevent a memory leak with non-native\n\t\t// event in IE.\n\t\thandle.elem = elem;\n\n\t\t// Handle multiple events separated by a space\n\t\t// jQuery(...).bind(\"mouseover mouseout\", fn);\n\t\tjQuery.each(types.split(/\\s+/), function(index, type) {\n\t\t\t// Namespaced event handlers\n\t\t\tvar parts = type.split(\".\");\n\t\t\ttype = parts[0];\n\t\t\thandler.type = parts[1];\n\n\t\t\t// Get the current list of functions bound to this event\n\t\t\tvar handlers = events[type];\n\n\t\t\t// Init the event handler queue\n\t\t\tif (!handlers) {\n\t\t\t\thandlers = events[type] = {};\n\n\t\t\t\t// Check for a special event handler\n\t\t\t\t// Only use addEventListener/attachEvent if the special\n\t\t\t\t// events handler returns false\n\t\t\t\tif ( !jQuery.event.special[type] || jQuery.event.special[type].setup.call(elem) === false ) {\n\t\t\t\t\t// Bind the global event handler to the element\n\t\t\t\t\tif (elem.addEventListener)\n\t\t\t\t\t\telem.addEventListener(type, handle, false);\n\t\t\t\t\telse if (elem.attachEvent)\n\t\t\t\t\t\telem.attachEvent(\"on\" + type, handle);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add the function to the element's handler list\n\t\t\thandlers[handler.guid] = handler;\n\n\t\t\t// Keep track of which events have been used, for global triggering\n\t\t\tjQuery.event.global[type] = true;\n\t\t});\n\n\t\t// Nullify elem to prevent memory leaks in IE\n\t\telem = null;\n\t},\n\n\tguid: 1,\n\tglobal: {},\n\n\t// Detach an event or set of events from an element\n\tremove: function(elem, types, handler) {\n\t\t// don't do events on text and comment nodes\n\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\treturn;\n\n\t\tvar events = jQuery.data(elem, \"events\"), ret, index;\n\n\t\tif ( events ) {"}]},
{"id":"3cfc78e400ced5d7fecddb392fa61a946aa916b9","instances":[{"path":"./jquery-data/1.2.6/src/fx.js","lines":[1,424],"code":"jQuery.fn.extend({\n\tshow: function(speed,callback){\n\t\treturn speed ?\n\t\t\tthis.animate({\n\t\t\t\theight: \"show\", width: \"show\", opacity: \"show\"\n\t\t\t}, speed, callback) :\n\n\t\t\tthis.filter(\":hidden\").each(function(){\n\t\t\t\tthis.style.display = this.oldblock || \"\";\n\t\t\t\tif ( jQuery.css(this,\"display\") == \"none\" ) {\n\t\t\t\t\tvar elem = jQuery(\"<\" + this.tagName + \" />\").appendTo(\"body\");\n\t\t\t\t\tthis.style.display = elem.css(\"display\");\n\t\t\t\t\t// handle an edge condition where css is - div { display:none; } or similar\n\t\t\t\t\tif (this.style.display == \"none\")\n\t\t\t\t\t\tthis.style.display = \"block\";\n\t\t\t\t\telem.remove();\n\t\t\t\t}\n\t\t\t}).end();\n\t},\n\n\thide: function(speed,callback){\n\t\treturn speed ?\n\t\t\tthis.animate({\n\t\t\t\theight: \"hide\", width: \"hide\", opacity: \"hide\"\n\t\t\t}, speed, callback) :\n\n\t\t\tthis.filter(\":visible\").each(function(){\n\t\t\t\tthis.oldblock = this.oldblock || jQuery.css(this,\"display\");\n\t\t\t\tthis.style.display = \"none\";\n\t\t\t}).end();\n\t},\n\n\t// Save the old toggle function\n\t_toggle: jQuery.fn.toggle,\n\n\ttoggle: function( fn, fn2 ){\n\t\treturn jQuery.isFunction(fn) && jQuery.isFunction(fn2) ?\n\t\t\tthis._toggle.apply( this, arguments ) :\n\t\t\tfn ?\n\t\t\t\tthis.animate({\n\t\t\t\t\theight: \"toggle\", width: \"toggle\", opacity: \"toggle\"\n\t\t\t\t}, fn, fn2) :\n\t\t\t\tthis.each(function(){\n\t\t\t\t\tjQuery(this)[ jQuery(this).is(\":hidden\") ? \"show\" : \"hide\" ]();\n\t\t\t\t});\n\t},\n\n\tslideDown: function(speed,callback){\n\t\treturn this.animate({height: \"show\"}, speed, callback);\n\t},\n\n\tslideUp: function(speed,callback){\n\t\treturn this.animate({height: \"hide\"}, speed, callback);\n\t},\n\n\tslideToggle: function(speed, callback){\n\t\treturn this.animate({height: \"toggle\"}, speed, callback);\n\t},\n\n\tfadeIn: function(speed, callback){\n\t\treturn this.animate({opacity: \"show\"}, speed, callback);\n\t},\n\n\tfadeOut: function(speed, callback){\n\t\treturn this.animate({opacity: \"hide\"}, speed, callback);\n\t},\n\n\tfadeTo: function(speed,to,callback){\n\t\treturn this.animate({opacity: to}, speed, callback);\n\t},\n\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar optall = jQuery.speed(speed, easing, callback);\n\n\t\treturn this[ optall.queue === false ? \"each\" : \"queue\" ](function(){\n\t\t\tif ( this.nodeType != 1)\n\t\t\t\treturn false;\n\n\t\t\tvar opt = jQuery.extend({}, optall), p,\n\t\t\t\thidden = jQuery(this).is(\":hidden\"), self = this;\n\n\t\t\tfor ( p in prop ) {\n\t\t\t\tif ( prop[p] == \"hide\" && hidden || prop[p] == \"show\" && !hidden )\n\t\t\t\t\treturn opt.complete.call(this);\n\n\t\t\t\tif ( p == \"height\" || p == \"width\" ) {\n\t\t\t\t\t// Store display property\n\t\t\t\t\topt.display = jQuery.css(this, \"display\");\n\n\t\t\t\t\t// Make sure that nothing sneaks out\n\t\t\t\t\topt.overflow = this.style.overflow;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( opt.overflow != null )\n\t\t\t\tthis.style.overflow = \"hidden\";\n\n\t\t\topt.curAnim = jQuery.extend({}, prop);\n\n\t\t\tjQuery.each( prop, function(name, val){"},{"path":"./jquery-data/1.2.4/src/fx.js","lines":[1,424],"code":"jQuery.fn.extend({\n\tshow: function(speed,callback){\n\t\treturn speed ?\n\t\t\tthis.animate({\n\t\t\t\theight: \"show\", width: \"show\", opacity: \"show\"\n\t\t\t}, speed, callback) :\n\n\t\t\tthis.filter(\":hidden\").each(function(){\n\t\t\t\tthis.style.display = this.oldblock || \"\";\n\t\t\t\tif ( jQuery.css(this,\"display\") == \"none\" ) {\n\t\t\t\t\tvar elem = jQuery(\"<\" + this.tagName + \" />\").appendTo(\"body\");\n\t\t\t\t\tthis.style.display = elem.css(\"display\");\n\t\t\t\t\t// handle an edge condition where css is - div { display:none; } or similar\n\t\t\t\t\tif (this.style.display == \"none\")\n\t\t\t\t\t\tthis.style.display = \"block\";\n\t\t\t\t\telem.remove();\n\t\t\t\t}\n\t\t\t}).end();\n\t},\n\n\thide: function(speed,callback){\n\t\treturn speed ?\n\t\t\tthis.animate({\n\t\t\t\theight: \"hide\", width: \"hide\", opacity: \"hide\"\n\t\t\t}, speed, callback) :\n\n\t\t\tthis.filter(\":visible\").each(function(){\n\t\t\t\tthis.oldblock = this.oldblock || jQuery.css(this,\"display\");\n\t\t\t\tthis.style.display = \"none\";\n\t\t\t}).end();\n\t},\n\n\t// Save the old toggle function\n\t_toggle: jQuery.fn.toggle,\n\n\ttoggle: function( fn, fn2 ){\n\t\treturn jQuery.isFunction(fn) && jQuery.isFunction(fn2) ?\n\t\t\tthis._toggle.apply( this, arguments ) :\n\t\t\tfn ?\n\t\t\t\tthis.animate({\n\t\t\t\t\theight: \"toggle\", width: \"toggle\", opacity: \"toggle\"\n\t\t\t\t}, fn, fn2) :\n\t\t\t\tthis.each(function(){\n\t\t\t\t\tjQuery(this)[ jQuery(this).is(\":hidden\") ? \"show\" : \"hide\" ]();\n\t\t\t\t});\n\t},\n\n\tslideDown: function(speed,callback){\n\t\treturn this.animate({height: \"show\"}, speed, callback);\n\t},\n\n\tslideUp: function(speed,callback){\n\t\treturn this.animate({height: \"hide\"}, speed, callback);\n\t},\n\n\tslideToggle: function(speed, callback){\n\t\treturn this.animate({height: \"toggle\"}, speed, callback);\n\t},\n\n\tfadeIn: function(speed, callback){\n\t\treturn this.animate({opacity: \"show\"}, speed, callback);\n\t},\n\n\tfadeOut: function(speed, callback){\n\t\treturn this.animate({opacity: \"hide\"}, speed, callback);\n\t},\n\n\tfadeTo: function(speed,to,callback){\n\t\treturn this.animate({opacity: to}, speed, callback);\n\t},\n\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar optall = jQuery.speed(speed, easing, callback);\n\n\t\treturn this[ optall.queue === false ? \"each\" : \"queue\" ](function(){\n\t\t\tif ( this.nodeType != 1)\n\t\t\t\treturn false;\n\n\t\t\tvar opt = jQuery.extend({}, optall), p,\n\t\t\t\thidden = jQuery(this).is(\":hidden\"), self = this;\n\n\t\t\tfor ( p in prop ) {\n\t\t\t\tif ( prop[p] == \"hide\" && hidden || prop[p] == \"show\" && !hidden )\n\t\t\t\t\treturn opt.complete.call(this);\n\n\t\t\t\tif ( p == \"height\" || p == \"width\" ) {\n\t\t\t\t\t// Store display property\n\t\t\t\t\topt.display = jQuery.css(this, \"display\");\n\n\t\t\t\t\t// Make sure that nothing sneaks out\n\t\t\t\t\topt.overflow = this.style.overflow;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( opt.overflow != null )\n\t\t\t\tthis.style.overflow = \"hidden\";\n\n\t\t\topt.curAnim = jQuery.extend({}, prop);\n\n\t\t\tjQuery.each( prop, function(name, val){"}]},
{"id":"3cfc78e400ced5d7fecddb392fa61a946aa916b9","instances":[{"path":"./jquery-data/1.2.6/src/fx.js","lines":[1,424],"code":"jQuery.fn.extend({\n\tshow: function(speed,callback){\n\t\treturn speed ?\n\t\t\tthis.animate({\n\t\t\t\theight: \"show\", width: \"show\", opacity: \"show\"\n\t\t\t}, speed, callback) :\n\n\t\t\tthis.filter(\":hidden\").each(function(){\n\t\t\t\tthis.style.display = this.oldblock || \"\";\n\t\t\t\tif ( jQuery.css(this,\"display\") == \"none\" ) {\n\t\t\t\t\tvar elem = jQuery(\"<\" + this.tagName + \" />\").appendTo(\"body\");\n\t\t\t\t\tthis.style.display = elem.css(\"display\");\n\t\t\t\t\t// handle an edge condition where css is - div { display:none; } or similar\n\t\t\t\t\tif (this.style.display == \"none\")\n\t\t\t\t\t\tthis.style.display = \"block\";\n\t\t\t\t\telem.remove();\n\t\t\t\t}\n\t\t\t}).end();\n\t},\n\n\thide: function(speed,callback){\n\t\treturn speed ?\n\t\t\tthis.animate({\n\t\t\t\theight: \"hide\", width: \"hide\", opacity: \"hide\"\n\t\t\t}, speed, callback) :\n\n\t\t\tthis.filter(\":visible\").each(function(){\n\t\t\t\tthis.oldblock = this.oldblock || jQuery.css(this,\"display\");\n\t\t\t\tthis.style.display = \"none\";\n\t\t\t}).end();\n\t},\n\n\t// Save the old toggle function\n\t_toggle: jQuery.fn.toggle,\n\n\ttoggle: function( fn, fn2 ){\n\t\treturn jQuery.isFunction(fn) && jQuery.isFunction(fn2) ?\n\t\t\tthis._toggle.apply( this, arguments ) :\n\t\t\tfn ?\n\t\t\t\tthis.animate({\n\t\t\t\t\theight: \"toggle\", width: \"toggle\", opacity: \"toggle\"\n\t\t\t\t}, fn, fn2) :\n\t\t\t\tthis.each(function(){\n\t\t\t\t\tjQuery(this)[ jQuery(this).is(\":hidden\") ? \"show\" : \"hide\" ]();\n\t\t\t\t});\n\t},\n\n\tslideDown: function(speed,callback){\n\t\treturn this.animate({height: \"show\"}, speed, callback);\n\t},\n\n\tslideUp: function(speed,callback){\n\t\treturn this.animate({height: \"hide\"}, speed, callback);\n\t},\n\n\tslideToggle: function(speed, callback){\n\t\treturn this.animate({height: \"toggle\"}, speed, callback);\n\t},\n\n\tfadeIn: function(speed, callback){\n\t\treturn this.animate({opacity: \"show\"}, speed, callback);\n\t},\n\n\tfadeOut: function(speed, callback){\n\t\treturn this.animate({opacity: \"hide\"}, speed, callback);\n\t},\n\n\tfadeTo: function(speed,to,callback){\n\t\treturn this.animate({opacity: to}, speed, callback);\n\t},\n\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar optall = jQuery.speed(speed, easing, callback);\n\n\t\treturn this[ optall.queue === false ? \"each\" : \"queue\" ](function(){\n\t\t\tif ( this.nodeType != 1)\n\t\t\t\treturn false;\n\n\t\t\tvar opt = jQuery.extend({}, optall), p,\n\t\t\t\thidden = jQuery(this).is(\":hidden\"), self = this;\n\n\t\t\tfor ( p in prop ) {\n\t\t\t\tif ( prop[p] == \"hide\" && hidden || prop[p] == \"show\" && !hidden )\n\t\t\t\t\treturn opt.complete.call(this);\n\n\t\t\t\tif ( p == \"height\" || p == \"width\" ) {\n\t\t\t\t\t// Store display property\n\t\t\t\t\topt.display = jQuery.css(this, \"display\");\n\n\t\t\t\t\t// Make sure that nothing sneaks out\n\t\t\t\t\topt.overflow = this.style.overflow;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( opt.overflow != null )\n\t\t\t\tthis.style.overflow = \"hidden\";\n\n\t\t\topt.curAnim = jQuery.extend({}, prop);\n\n\t\t\tjQuery.each( prop, function(name, val){"},{"path":"./jquery-data/1.2.4/src/fx.js","lines":[1,424],"code":"jQuery.fn.extend({\n\tshow: function(speed,callback){\n\t\treturn speed ?\n\t\t\tthis.animate({\n\t\t\t\theight: \"show\", width: \"show\", opacity: \"show\"\n\t\t\t}, speed, callback) :\n\n\t\t\tthis.filter(\":hidden\").each(function(){\n\t\t\t\tthis.style.display = this.oldblock || \"\";\n\t\t\t\tif ( jQuery.css(this,\"display\") == \"none\" ) {\n\t\t\t\t\tvar elem = jQuery(\"<\" + this.tagName + \" />\").appendTo(\"body\");\n\t\t\t\t\tthis.style.display = elem.css(\"display\");\n\t\t\t\t\t// handle an edge condition where css is - div { display:none; } or similar\n\t\t\t\t\tif (this.style.display == \"none\")\n\t\t\t\t\t\tthis.style.display = \"block\";\n\t\t\t\t\telem.remove();\n\t\t\t\t}\n\t\t\t}).end();\n\t},\n\n\thide: function(speed,callback){\n\t\treturn speed ?\n\t\t\tthis.animate({\n\t\t\t\theight: \"hide\", width: \"hide\", opacity: \"hide\"\n\t\t\t}, speed, callback) :\n\n\t\t\tthis.filter(\":visible\").each(function(){\n\t\t\t\tthis.oldblock = this.oldblock || jQuery.css(this,\"display\");\n\t\t\t\tthis.style.display = \"none\";\n\t\t\t}).end();\n\t},\n\n\t// Save the old toggle function\n\t_toggle: jQuery.fn.toggle,\n\n\ttoggle: function( fn, fn2 ){\n\t\treturn jQuery.isFunction(fn) && jQuery.isFunction(fn2) ?\n\t\t\tthis._toggle.apply( this, arguments ) :\n\t\t\tfn ?\n\t\t\t\tthis.animate({\n\t\t\t\t\theight: \"toggle\", width: \"toggle\", opacity: \"toggle\"\n\t\t\t\t}, fn, fn2) :\n\t\t\t\tthis.each(function(){\n\t\t\t\t\tjQuery(this)[ jQuery(this).is(\":hidden\") ? \"show\" : \"hide\" ]();\n\t\t\t\t});\n\t},\n\n\tslideDown: function(speed,callback){\n\t\treturn this.animate({height: \"show\"}, speed, callback);\n\t},\n\n\tslideUp: function(speed,callback){\n\t\treturn this.animate({height: \"hide\"}, speed, callback);\n\t},\n\n\tslideToggle: function(speed, callback){\n\t\treturn this.animate({height: \"toggle\"}, speed, callback);\n\t},\n\n\tfadeIn: function(speed, callback){\n\t\treturn this.animate({opacity: \"show\"}, speed, callback);\n\t},\n\n\tfadeOut: function(speed, callback){\n\t\treturn this.animate({opacity: \"hide\"}, speed, callback);\n\t},\n\n\tfadeTo: function(speed,to,callback){\n\t\treturn this.animate({opacity: to}, speed, callback);\n\t},\n\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar optall = jQuery.speed(speed, easing, callback);\n\n\t\treturn this[ optall.queue === false ? \"each\" : \"queue\" ](function(){\n\t\t\tif ( this.nodeType != 1)\n\t\t\t\treturn false;\n\n\t\t\tvar opt = jQuery.extend({}, optall), p,\n\t\t\t\thidden = jQuery(this).is(\":hidden\"), self = this;\n\n\t\t\tfor ( p in prop ) {\n\t\t\t\tif ( prop[p] == \"hide\" && hidden || prop[p] == \"show\" && !hidden )\n\t\t\t\t\treturn opt.complete.call(this);\n\n\t\t\t\tif ( p == \"height\" || p == \"width\" ) {\n\t\t\t\t\t// Store display property\n\t\t\t\t\topt.display = jQuery.css(this, \"display\");\n\n\t\t\t\t\t// Make sure that nothing sneaks out\n\t\t\t\t\topt.overflow = this.style.overflow;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( opt.overflow != null )\n\t\t\t\tthis.style.overflow = \"hidden\";\n\n\t\t\topt.curAnim = jQuery.extend({}, prop);\n\n\t\t\tjQuery.each( prop, function(name, val){"}]},
{"id":"e979bf348a98828591aa24111ebef9d95b2f64d4","instances":[{"path":"./jquery-data/1.2.6/src/ajax.js","lines":[1,509],"code":"jQuery.fn.extend({\n\t// Keep a copy of the old load\n\t_load: jQuery.fn.load,\n\n\tload: function( url, params, callback ) {\n\t\tif ( typeof url != 'string' )\n\t\t\treturn this._load( url );\n\n\t\tvar off = url.indexOf(\" \");\n\t\tif ( off >= 0 ) {\n\t\t\tvar selector = url.slice(off, url.length);\n\t\t\turl = url.slice(0, off);\n\t\t}\n\n\t\tcallback = callback || function(){};\n\n\t\t// Default to a GET request\n\t\tvar type = \"GET\";\n\n\t\t// If the second parameter was provided\n\t\tif ( params )\n\t\t\t// If it's a function\n\t\t\tif ( jQuery.isFunction( params ) ) {\n\t\t\t\t// We assume that it's the callback\n\t\t\t\tcallback = params;\n\t\t\t\tparams = null;\n\n\t\t\t// Otherwise, build a param string\n\t\t\t} else {\n\t\t\t\tparams = jQuery.param( params );\n\t\t\t\ttype = \"POST\";\n\t\t\t}\n\n\t\tvar self = this;\n\n\t\t// Request the remote document\n\t\tjQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: type,\n\t\t\tdataType: \"html\",\n\t\t\tdata: params,\n\t\t\tcomplete: function(res, status){\n\t\t\t\t// If successful, inject the HTML into all the matched elements\n\t\t\t\tif ( status == \"success\" || status == \"notmodified\" )\n\t\t\t\t\t// See if a selector was specified\n\t\t\t\t\tself.html( selector ?\n\t\t\t\t\t\t// Create a dummy div to hold the results\n\t\t\t\t\t\tjQuery(\"<div/>\")\n\t\t\t\t\t\t\t// inject the contents of the document in, removing the scripts\n\t\t\t\t\t\t\t// to avoid any 'Permission Denied' errors in IE\n\t\t\t\t\t\t\t.append(res.responseText.replace(/<script(.|\\s)*?\\/script>/g, \"\"))\n\n\t\t\t\t\t\t\t// Locate the specified elements\n\t\t\t\t\t\t\t.find(selector) :\n\n\t\t\t\t\t\t// If not, just inject the full result\n\t\t\t\t\t\tres.responseText );\n\n\t\t\t\tself.each( callback, [res.responseText, status, res] );\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t},\n\n\tserialize: function() {\n\t\treturn jQuery.param(this.serializeArray());\n\t},\n\tserializeArray: function() {\n\t\treturn this.map(function(){\n\t\t\treturn jQuery.nodeName(this, \"form\") ?\n\t\t\t\tjQuery.makeArray(this.elements) : this;\n\t\t})\n\t\t.filter(function(){\n\t\t\treturn this.name && !this.disabled &&\n\t\t\t\t(this.checked || /select|textarea/i.test(this.nodeName) ||\n\t\t\t\t\t/text|hidden|password/i.test(this.type));\n\t\t})\n\t\t.map(function(i, elem){\n\t\t\tvar val = jQuery(this).val();\n\t\t\treturn val == null ? null :\n\t\t\t\tval.constructor == Array ?\n\t\t\t\t\tjQuery.map( val, function(val, i){\n\t\t\t\t\t\treturn {name: elem.name, value: val};\n\t\t\t\t\t}) :\n\t\t\t\t\t{name: elem.name, value: val};\n\t\t}).get();\n\t}\n});\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( \"ajaxStart,ajaxStop,ajaxComplete,ajaxError,ajaxSuccess,ajaxSend\".split(\",\"), function(i,o){\n\tjQuery.fn[o] = function(f){\n\t\treturn this.bind(o, f);\n\t};\n});\n\nvar jsc = now();\n\njQuery.extend({\n\tget: function( url, data, callback, type ) {"},{"path":"./jquery-data/1.2.4/src/ajax.js","lines":[1,509],"code":"jQuery.fn.extend({\n\t// Keep a copy of the old load\n\t_load: jQuery.fn.load,\n\n\tload: function( url, params, callback ) {\n\t\tif ( typeof url != 'string' )\n\t\t\treturn this._load( url );\n\n\t\tvar off = url.indexOf(\" \");\n\t\tif ( off >= 0 ) {\n\t\t\tvar selector = url.slice(off, url.length);\n\t\t\turl = url.slice(0, off);\n\t\t}\n\n\t\tcallback = callback || function(){};\n\n\t\t// Default to a GET request\n\t\tvar type = \"GET\";\n\n\t\t// If the second parameter was provided\n\t\tif ( params )\n\t\t\t// If it's a function\n\t\t\tif ( jQuery.isFunction( params ) ) {\n\t\t\t\t// We assume that it's the callback\n\t\t\t\tcallback = params;\n\t\t\t\tparams = null;\n\n\t\t\t// Otherwise, build a param string\n\t\t\t} else {\n\t\t\t\tparams = jQuery.param( params );\n\t\t\t\ttype = \"POST\";\n\t\t\t}\n\n\t\tvar self = this;\n\n\t\t// Request the remote document\n\t\tjQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: type,\n\t\t\tdataType: \"html\",\n\t\t\tdata: params,\n\t\t\tcomplete: function(res, status){\n\t\t\t\t// If successful, inject the HTML into all the matched elements\n\t\t\t\tif ( status == \"success\" || status == \"notmodified\" )\n\t\t\t\t\t// See if a selector was specified\n\t\t\t\t\tself.html( selector ?\n\t\t\t\t\t\t// Create a dummy div to hold the results\n\t\t\t\t\t\tjQuery(\"<div/>\")\n\t\t\t\t\t\t\t// inject the contents of the document in, removing the scripts\n\t\t\t\t\t\t\t// to avoid any 'Permission Denied' errors in IE\n\t\t\t\t\t\t\t.append(res.responseText.replace(/<script(.|\\s)*?\\/script>/g, \"\"))\n\n\t\t\t\t\t\t\t// Locate the specified elements\n\t\t\t\t\t\t\t.find(selector) :\n\n\t\t\t\t\t\t// If not, just inject the full result\n\t\t\t\t\t\tres.responseText );\n\n\t\t\t\tself.each( callback, [res.responseText, status, res] );\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t},\n\n\tserialize: function() {\n\t\treturn jQuery.param(this.serializeArray());\n\t},\n\tserializeArray: function() {\n\t\treturn this.map(function(){\n\t\t\treturn jQuery.nodeName(this, \"form\") ?\n\t\t\t\tjQuery.makeArray(this.elements) : this;\n\t\t})\n\t\t.filter(function(){\n\t\t\treturn this.name && !this.disabled &&\n\t\t\t\t(this.checked || /select|textarea/i.test(this.nodeName) ||\n\t\t\t\t\t/text|hidden|password/i.test(this.type));\n\t\t})\n\t\t.map(function(i, elem){\n\t\t\tvar val = jQuery(this).val();\n\t\t\treturn val == null ? null :\n\t\t\t\tval.constructor == Array ?\n\t\t\t\t\tjQuery.map( val, function(val, i){\n\t\t\t\t\t\treturn {name: elem.name, value: val};\n\t\t\t\t\t}) :\n\t\t\t\t\t{name: elem.name, value: val};\n\t\t}).get();\n\t}\n});\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( \"ajaxStart,ajaxStop,ajaxComplete,ajaxError,ajaxSuccess,ajaxSend\".split(\",\"), function(i,o){\n\tjQuery.fn[o] = function(f){\n\t\treturn this.bind(o, f);\n\t};\n});\n\nvar jsc = now();\n\njQuery.extend({\n\tget: function( url, data, callback, type ) {"}]},
{"id":"7436e763532b4c57651a3c823c7f899ff71ee7a3","instances":[{"path":"./jquery-data/1.2.6/src/core.js","lines":[1,401],"code":"/*\n * jQuery @VERSION - New Wave Javascript\n *\n * Copyright (c) 2008 John Resig (jquery.com)\n * Dual licensed under the MIT (MIT-LICENSE.txt)\n * and GPL (GPL-LICENSE.txt) licenses.\n *\n * $Date$\n * $Rev$\n */\n\n// Map over jQuery in case of overwrite\nvar _jQuery = window.jQuery,\n// Map over the $ in case of overwrite\n\t_$ = window.$;\n\nvar jQuery = window.jQuery = window.$ = function( selector, context ) {\n\t// The jQuery object is actually just the init constructor 'enhanced'\n\treturn new jQuery.fn.init( selector, context );\n};\n\n// A simple way to check for HTML strings or ID strings\n// (both of which we optimize for)\nvar quickExpr = /^[^<]*(<(.|\\s)+>)[^>]*$|^#(\\w+)$/,\n\n// Is it a simple selector\n\tisSimple = /^.[^:#\\[\\.]*$/,\n\n// Will speed up references to undefined, and allows munging its name.\n\tundefined;\n\njQuery.fn = jQuery.prototype = {\n\tinit: function( selector, context ) {\n\t\t// Make sure that a selection was provided\n\t\tselector = selector || document;\n\n\t\t// Handle $(DOMElement)\n\t\tif ( selector.nodeType ) {\n\t\t\tthis[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\t\t}\n\t\t// Handle HTML strings\n\t\tif ( typeof selector == \"string\" ) {\n\t\t\t// Are we dealing with HTML string or an ID?\n\t\t\tvar match = quickExpr.exec( selector );\n\n\t\t\t// Verify a match, and that no context was specified for #id\n\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[1] )\n\t\t\t\t\tselector = jQuery.clean( [ match[1] ], context );\n\n\t\t\t\t// HANDLE: $(\"#id\")\n\t\t\t\telse {\n\t\t\t\t\tvar elem = document.getElementById( match[3] );\n\n\t\t\t\t\t// Make sure an element was located\n\t\t\t\t\tif ( elem ){\n\t\t\t\t\t\t// Handle the case where IE and Opera return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id != match[3] )\n\t\t\t\t\t\t\treturn jQuery().find( selector );\n\n\t\t\t\t\t\t// Otherwise, we inject the element directly into the jQuery object\n\t\t\t\t\t\treturn jQuery( elem );\n\t\t\t\t\t}\n\t\t\t\t\tselector = [];\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, [context])\n\t\t\t// (which is just equivalent to: $(content).find(expr)\n\t\t\t} else\n\t\t\t\treturn jQuery( context ).find( selector );\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) )\n\t\t\treturn jQuery( document )[ jQuery.fn.ready ? \"ready\" : \"load\" ]( selector );\n\n\t\treturn this.setArray(jQuery.makeArray(selector));\n\t},\n\n\t// The current version of jQuery being used\n\tjquery: \"@VERSION\",\n\n\t// The number of elements contained in the matched element set\n\tsize: function() {\n\t\treturn this.length;\n\t},\n\n\t// The number of elements contained in the matched element set\n\tlength: 0,\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num == undefined ?\n"},{"path":"./jquery-data/1.2.4/src/core.js","lines":[1,401],"code":"/*\n * jQuery @VERSION - New Wave Javascript\n *\n * Copyright (c) 2008 John Resig (jquery.com)\n * Dual licensed under the MIT (MIT-LICENSE.txt)\n * and GPL (GPL-LICENSE.txt) licenses.\n *\n * $Date$\n * $Rev$\n */\n\n// Map over jQuery in case of overwrite\nvar _jQuery = window.jQuery,\n// Map over the $ in case of overwrite\n\t_$ = window.$;\n\nvar jQuery = window.jQuery = window.$ = function( selector, context ) {\n\t// The jQuery object is actually just the init constructor 'enhanced'\n\treturn new jQuery.fn.init( selector, context );\n};\n\n// A simple way to check for HTML strings or ID strings\n// (both of which we optimize for)\nvar quickExpr = /^[^<]*(<(.|\\s)+>)[^>]*$|^#(\\w+)$/,\n\n// Is it a simple selector\n\tisSimple = /^.[^:#\\[\\.]*$/,\n\n// Will speed up references to undefined, and allows munging its name.\n\tundefined;\n\njQuery.fn = jQuery.prototype = {\n\tinit: function( selector, context ) {\n\t\t// Make sure that a selection was provided\n\t\tselector = selector || document;\n\n\t\t// Handle $(DOMElement)\n\t\tif ( selector.nodeType ) {\n\t\t\tthis[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\t\t}\n\t\t// Handle HTML strings\n\t\tif ( typeof selector == \"string\" ) {\n\t\t\t// Are we dealing with HTML string or an ID?\n\t\t\tvar match = quickExpr.exec( selector );\n\n\t\t\t// Verify a match, and that no context was specified for #id\n\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[1] )\n\t\t\t\t\tselector = jQuery.clean( [ match[1] ], context );\n\n\t\t\t\t// HANDLE: $(\"#id\")\n\t\t\t\telse {\n\t\t\t\t\tvar elem = document.getElementById( match[3] );\n\n\t\t\t\t\t// Make sure an element was located\n\t\t\t\t\tif ( elem ){\n\t\t\t\t\t\t// Handle the case where IE and Opera return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id != match[3] )\n\t\t\t\t\t\t\treturn jQuery().find( selector );\n\n\t\t\t\t\t\t// Otherwise, we inject the element directly into the jQuery object\n\t\t\t\t\t\treturn jQuery( elem );\n\t\t\t\t\t}\n\t\t\t\t\tselector = [];\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, [context])\n\t\t\t// (which is just equivalent to: $(content).find(expr)\n\t\t\t} else\n\t\t\t\treturn jQuery( context ).find( selector );\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) )\n\t\t\treturn jQuery( document )[ jQuery.fn.ready ? \"ready\" : \"load\" ]( selector );\n\n\t\treturn this.setArray(jQuery.makeArray(selector));\n\t},\n\n\t// The current version of jQuery being used\n\tjquery: \"@VERSION\",\n\n\t// The number of elements contained in the matched element set\n\tsize: function() {\n\t\treturn this.length;\n\t},\n\n\t// The number of elements contained in the matched element set\n\tlength: 0,\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num == undefined ?\n"}]},
{"id":"6ff4aabe1c628486ab747d39c5ad3e479161e289","instances":[{"path":"./jquery-data/1.2.6/src/core.js","lines":[407,433],"code":"\treturn this.each(function(){\n\t\tif ( this.nodeType != 1 )\n\t\t\treturn;\n\n\t\tif ( value.constructor == Array && /radio|checkbox/.test( this.type ) )\n\t\t\tthis.checked = (jQuery.inArray(this.value, value) >= 0 ||\n\t\t\t\tjQuery.inArray(this.name, value) >= 0);\n\n\t\telse if ( jQuery.nodeName( this, \"select\" ) ) {\n\t\t\tvar values = jQuery.makeArray(value);\n\n\t\t\tjQuery( \"option\", this ).each(function(){\n\t\t\t\tthis.selected = (jQuery.inArray( this.value, values ) >= 0 ||\n\t\t\t\t\tjQuery.inArray( this.text, values ) >= 0);\n\t\t\t});\n\n\t\t\tif ( !values.length )\n\t\t\t\tthis.selectedIndex = -1;\n\n\t\t} else\n\t\t\tthis.value = value;\n\t});\n},\n\nhtml: function( value ) {\n\treturn value == undefined ?\n\t\t(this[0] ?"},{"path":"./jquery-data/1.2.4/src/core.js","lines":[404,430],"code":"\treturn this.each(function(){\n\t\tif ( this.nodeType != 1 )\n\t\t\treturn;\n\n\t\tif ( value.constructor == Array && /radio|checkbox/.test( this.type ) )\n\t\t\tthis.checked = (jQuery.inArray(this.value, value) >= 0 ||\n\t\t\t\tjQuery.inArray(this.name, value) >= 0);\n\n\t\telse if ( jQuery.nodeName( this, \"select\" ) ) {\n\t\t\tvar values = jQuery.makeArray(value);\n\n\t\t\tjQuery( \"option\", this ).each(function(){\n\t\t\t\tthis.selected = (jQuery.inArray( this.value, values ) >= 0 ||\n\t\t\t\t\tjQuery.inArray( this.text, values ) >= 0);\n\t\t\t});\n\n\t\t\tif ( !values.length )\n\t\t\t\tthis.selectedIndex = -1;\n\n\t\t} else\n\t\t\tthis.value = value;\n\t});\n},\n\nhtml: function( value ) {\n\treturn value == undefined ?\n\t\t(this.length ?"}]},
{"id":"f9b9ee6dfd9b9ccd588fe9c62c7c7bb66e0a91a3","instances":[{"path":"./jquery-data/1.2.6/src/core.js","lines":[434,510],"code":"\t\t\tthis[0].innerHTML :\n\t\t\tnull) :\n\t\tthis.empty().append( value );\n},\n\nreplaceWith: function( value ) {\n\treturn this.after( value ).remove();\n},\n\neq: function( i ) {\n\treturn this.slice( i, i + 1 );\n},\n\nslice: function() {\n\treturn this.pushStack( Array.prototype.slice.apply( this, arguments ) );\n},\n\nmap: function( callback ) {\n\treturn this.pushStack( jQuery.map(this, function(elem, i){\n\t\treturn callback.call( elem, i, elem );\n\t}));\n},\n\nandSelf: function() {\n\treturn this.add( this.prevObject );\n},\n\ndata: function( key, value ){\n\tvar parts = key.split(\".\");\n\tparts[1] = parts[1] ? \".\" + parts[1] : \"\";\n\n\tif ( value === undefined ) {\n\t\tvar data = this.triggerHandler(\"getData\" + parts[1] + \"!\", [parts[0]]);\n\n\t\tif ( data === undefined && this.length )\n\t\t\tdata = jQuery.data( this[0], key );\n\n\t\treturn data === undefined && parts[1] ?\n\t\t\tthis.data( parts[0] ) :\n\t\t\tdata;\n\t} else\n\t\treturn this.trigger(\"setData\" + parts[1] + \"!\", [parts[0], value]).each(function(){\n\t\t\tjQuery.data( this, key, value );\n\t\t});\n},\n\nremoveData: function( key ){\n\treturn this.each(function(){\n\t\tjQuery.removeData( this, key );\n\t});\n},\n\ndomManip: function( args, table, reverse, callback ) {\n\tvar clone = this.length > 1, elems;\n\n\treturn this.each(function(){\n\t\tif ( !elems ) {\n\t\t\telems = jQuery.clean( args, this.ownerDocument );\n\n\t\t\tif ( reverse )\n\t\t\t\telems.reverse();\n\t\t}\n\n\t\tvar obj = this;\n\n\t\tif ( table && jQuery.nodeName( this, \"table\" ) && jQuery.nodeName( elems[0], \"tr\" ) )\n\t\t\tobj = this.getElementsByTagName(\"tbody\")[0] || this.appendChild( this.ownerDocument.createElement(\"tbody\") );\n\n\t\tvar scripts = jQuery( [] );\n\n\t\tjQuery.each(elems, function(){\n\t\t\tvar elem = clone ?\n\t\t\t\tjQuery( this ).clone( true )[0] :\n\t\t\t\tthis;\n\n\t\t\t// execute all scripts after the elements have been injected\n\t\t\tif ( jQuery.nodeName( elem, \"script\" ) )"},{"path":"./jquery-data/1.2.4/src/core.js","lines":[431,507],"code":"\t\t\tthis[0].innerHTML :\n\t\t\tnull) :\n\t\tthis.empty().append( value );\n},\n\nreplaceWith: function( value ) {\n\treturn this.after( value ).remove();\n},\n\neq: function( i ) {\n\treturn this.slice( i, i + 1 );\n},\n\nslice: function() {\n\treturn this.pushStack( Array.prototype.slice.apply( this, arguments ) );\n},\n\nmap: function( callback ) {\n\treturn this.pushStack( jQuery.map(this, function(elem, i){\n\t\treturn callback.call( elem, i, elem );\n\t}));\n},\n\nandSelf: function() {\n\treturn this.add( this.prevObject );\n},\n\ndata: function( key, value ){\n\tvar parts = key.split(\".\");\n\tparts[1] = parts[1] ? \".\" + parts[1] : \"\";\n\n\tif ( value === undefined ) {\n\t\tvar data = this.triggerHandler(\"getData\" + parts[1] + \"!\", [parts[0]]);\n\n\t\tif ( data === undefined && this.length )\n\t\t\tdata = jQuery.data( this[0], key );\n\n\t\treturn data === undefined && parts[1] ?\n\t\t\tthis.data( parts[0] ) :\n\t\t\tdata;\n\t} else\n\t\treturn this.trigger(\"setData\" + parts[1] + \"!\", [parts[0], value]).each(function(){\n\t\t\tjQuery.data( this, key, value );\n\t\t});\n},\n\nremoveData: function( key ){\n\treturn this.each(function(){\n\t\tjQuery.removeData( this, key );\n\t});\n},\n\ndomManip: function( args, table, reverse, callback ) {\n\tvar clone = this.length > 1, elems;\n\n\treturn this.each(function(){\n\t\tif ( !elems ) {\n\t\t\telems = jQuery.clean( args, this.ownerDocument );\n\n\t\t\tif ( reverse )\n\t\t\t\telems.reverse();\n\t\t}\n\n\t\tvar obj = this;\n\n\t\tif ( table && jQuery.nodeName( this, \"table\" ) && jQuery.nodeName( elems[0], \"tr\" ) )\n\t\t\tobj = this.getElementsByTagName(\"tbody\")[0] || this.appendChild( this.ownerDocument.createElement(\"tbody\") );\n\n\t\tvar scripts = jQuery( [] );\n\n\t\tjQuery.each(elems, function(){\n\t\t\tvar elem = clone ?\n\t\t\t\tjQuery( this ).clone( true )[0] :\n\t\t\t\tthis;\n\n\t\t\t// execute all scripts after the elements have been injected\n\t\t\tif ( jQuery.nodeName( elem, \"script\" ) ) {"}]},
{"id":"d192fbc15975db4f44e051c7366070175dfcf717","instances":[{"path":"./jquery-data/1.2.6/src/core.js","lines":[511,799],"code":"\t\t\t\t\tscripts = scripts.add( elem );\n\t\t\t\telse {\n\t\t\t\t\t// Remove any inner scripts for later evaluation\n\t\t\t\t\tif ( elem.nodeType == 1 )\n\t\t\t\t\t\tscripts = scripts.add( jQuery( \"script\", elem ).remove() );\n\n\t\t\t\t\t// Inject the elements into the document\n\t\t\t\t\tcallback.call( obj, elem );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tscripts.each( evalScript );\n\t\t});\n\t}\n};\n\n// Give the init function the jQuery prototype for later instantiation\njQuery.fn.init.prototype = jQuery.fn;\n\nfunction evalScript( i, elem ) {\n\tif ( elem.src )\n\t\tjQuery.ajax({\n\t\t\turl: elem.src,\n\t\t\tasync: false,\n\t\t\tdataType: \"script\"\n\t\t});\n\n\telse\n\t\tjQuery.globalEval( elem.text || elem.textContent || elem.innerHTML || \"\" );\n\n\tif ( elem.parentNode )\n\t\telem.parentNode.removeChild( elem );\n}\n\nfunction now(){\n\treturn +new Date;\n}\n\njQuery.extend = jQuery.fn.extend = function() {\n\t// copy reference to target object\n\tvar target = arguments[0] || {}, i = 1, length = arguments.length, deep = false, options;\n\n\t// Handle a deep copy situation\n\tif ( target.constructor == Boolean ) {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target != \"object\" && typeof target != \"function\" )\n\t\ttarget = {};\n\n\t// extend jQuery itself if only one argument is passed\n\tif ( length == i ) {\n\t\ttarget = this;\n\t\t--i;\n\t}\n\n\tfor ( ; i < length; i++ )\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null )\n\t\t\t// Extend the base object\n\t\t\tfor ( var name in options ) {\n\t\t\t\tvar src = target[ name ], copy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy )\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// Recurse if we're merging object values\n\t\t\t\tif ( deep && copy && typeof copy == \"object\" && !copy.nodeType )\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, \n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsrc || ( copy.length != null ? [ ] : { } )\n\t\t\t\t\t, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\telse if ( copy !== undefined )\n\t\t\t\t\ttarget[ name ] = copy;\n\n\t\t\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\nvar expando = \"jQuery\" + now(), uuid = 0, windowData = {},\n\t// exclude the following css properties to add px\n\texclude = /z-?index|font-?weight|opacity|zoom|line-?height/i,\n\t// cache defaultView\n\tdefaultView = document.defaultView || {};\n\njQuery.extend({\n\tnoConflict: function( deep ) {\n\t\twindow.$ = _$;\n\n\t\tif ( deep )\n\t\t\twindow.jQuery = _jQuery;"},{"path":"./jquery-data/1.2.4/src/core.js","lines":[508,796],"code":"\t\t\t\t\tscripts = scripts.add( elem );\n\t\t\t\t} else {\n\t\t\t\t\t// Remove any inner scripts for later evaluation\n\t\t\t\t\tif ( elem.nodeType == 1 )\n\t\t\t\t\t\tscripts = scripts.add( jQuery( \"script\", elem ).remove() );\n\n\t\t\t\t\t// Inject the elements into the document\n\t\t\t\t\tcallback.call( obj, elem );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tscripts.each( evalScript );\n\t\t});\n\t}\n};\n\n// Give the init function the jQuery prototype for later instantiation\njQuery.fn.init.prototype = jQuery.fn;\n\nfunction evalScript( i, elem ) {\n\tif ( elem.src )\n\t\tjQuery.ajax({\n\t\t\turl: elem.src,\n\t\t\tasync: false,\n\t\t\tdataType: \"script\"\n\t\t});\n\n\telse\n\t\tjQuery.globalEval( elem.text || elem.textContent || elem.innerHTML || \"\" );\n\n\tif ( elem.parentNode )\n\t\telem.parentNode.removeChild( elem );\n}\n\nfunction now(){\n\treturn +new Date;\n}\n\njQuery.extend = jQuery.fn.extend = function() {\n\t// copy reference to target object\n\tvar target = arguments[0] || {}, i = 1, length = arguments.length, deep = false, options;\n\n\t// Handle a deep copy situation\n\tif ( target.constructor == Boolean ) {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target != \"object\" && typeof target != \"function\" )\n\t\ttarget = {};\n\n\t// extend jQuery itself if only one argument is passed\n\tif ( length == i ) {\n\t\ttarget = this;\n\t\t--i;\n\t}\n\n\tfor ( ; i < length; i++ )\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null )\n\t\t\t// Extend the base object\n\t\t\tfor ( var name in options ) {\n\t\t\t\tvar src = target[ name ], copy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy )\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// Recurse if we're merging object values\n\t\t\t\tif ( deep && copy && typeof copy == \"object\" && !copy.nodeType )\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, \n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsrc || ( copy.length != null ? [ ] : { } )\n\t\t\t\t\t, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\telse if ( copy !== undefined )\n\t\t\t\t\ttarget[ name ] = copy;\n\n\t\t\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\nvar expando = \"jQuery\" + now(), uuid = 0, windowData = {},\n\t// exclude the following css properties to add px\n\texclude = /z-?index|font-?weight|opacity|zoom|line-?height/i,\n\t// cache defaultView\n\tdefaultView = document.defaultView || {};\n\njQuery.extend({\n\tnoConflict: function( deep ) {\n\t\twindow.$ = _$;\n\n\t\tif ( deep )\n\t\t\twindow.jQuery = _jQuery;"}]},
{"id":"6087c64fe635f6f24bc56a216f87fc9f5901a700","instances":[{"path":"./jquery-data/1.2.6/src/core.js","lines":[786,901],"code":"// A method for quickly swapping in/out CSS properties to get correct calculations\nswap: function( elem, options, callback ) {\n\tvar old = {};\n\t// Remember the old values, and insert the new ones\n\tfor ( var name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tcallback.call( elem );\n\n\t// Revert the old values\n\tfor ( var name in options )\n\t\telem.style[ name ] = old[ name ];\n},\n\ncss: function( elem, name, force ) {\n\tif ( name == \"width\" || name == \"height\" ) {\n\t\tvar val, props = { position: \"absolute\", visibility: \"hidden\", display:\"block\" }, which = name == \"width\" ? [ \"Left\", \"Right\" ] : [ \"Top\", \"Bottom\" ];\n\n\t\tfunction getWH() {\n\t\t\tval = name == \"width\" ? elem.offsetWidth : elem.offsetHeight;\n\t\t\tvar padding = 0, border = 0;\n\t\t\tjQuery.each( which, function() {\n\t\t\t\tpadding += parseFloat(jQuery.curCSS( elem, \"padding\" + this, true)) || 0;\n\t\t\t\tborder += parseFloat(jQuery.curCSS( elem, \"border\" + this + \"Width\", true)) || 0;\n\t\t\t});\n\t\t\tval -= Math.round(padding + border);\n\t\t}\n\n\t\tif ( jQuery(elem).is(\":visible\") )\n\t\t\tgetWH();\n\t\telse\n\t\t\tjQuery.swap( elem, props, getWH );\n\n\t\treturn Math.max(0, val);\n\t}\n\n\treturn jQuery.curCSS( elem, name, force );\n},\n\ncurCSS: function( elem, name, force ) {\n\tvar ret, style = elem.style;\n\n\t// A helper method for determining if an element's values are broken\n\tfunction color( elem ) {\n\t\tif ( !jQuery.browser.safari )\n\t\t\treturn false;\n\n\t\t// defaultView is cached\n\t\tvar ret = defaultView.getComputedStyle( elem, null );\n\t\treturn !ret || ret.getPropertyValue(\"color\") == \"\";\n\t}\n\n\t// We need to handle opacity special in IE\n\tif ( name == \"opacity\" && jQuery.browser.msie ) {\n\t\tret = jQuery.attr( style, \"opacity\" );\n\n\t\treturn ret == \"\" ?\n\t\t\t\"1\" :\n\t\t\tret;\n\t}\n\t// Opera sometimes will give the wrong display answer, this fixes it, see #2037\n\tif ( jQuery.browser.opera && name == \"display\" ) {\n\t\tvar save = style.outline;\n\t\tstyle.outline = \"0 solid black\";\n\t\tstyle.outline = save;\n\t}\n\n\t// Make sure we're using the right name for getting the float value\n\tif ( name.match( /float/i ) )\n\t\tname = styleFloat;\n\n\tif ( !force && style && style[ name ] )\n\t\tret = style[ name ];\n\n\telse if ( defaultView.getComputedStyle ) {\n\n\t\t// Only \"float\" is needed here\n\t\tif ( name.match( /float/i ) )\n\t\t\tname = \"float\";\n\n\t\tname = name.replace( /([A-Z])/g, \"-$1\" ).toLowerCase();\n\n\t\tvar computedStyle = defaultView.getComputedStyle( elem, null );\n\n\t\tif ( computedStyle && !color( elem ) )\n\t\t\tret = computedStyle.getPropertyValue( name );\n\n\t\t// If the element isn't reporting its values properly in Safari\n\t\t// then some display: none elements are involved\n\t\telse {\n\t\t\tvar swap = [], stack = [], a = elem, i = 0;\n\n\t\t\t// Locate all of the parent display: none elements\n\t\t\tfor ( ; a && color(a); a = a.parentNode )\n\t\t\t\tstack.unshift(a);\n\n\t\t\t// Go through and make them visible, but in reverse\n\t\t\t// (It would be better if we knew the exact display type that they had)"},{"path":"./jquery-data/1.2.4/src/core.js","lines":[783,898],"code":"// A method for quickly swapping in/out CSS properties to get correct calculations\nswap: function( elem, options, callback ) {\n\tvar old = {};\n\t// Remember the old values, and insert the new ones\n\tfor ( var name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tcallback.call( elem );\n\n\t// Revert the old values\n\tfor ( var name in options )\n\t\telem.style[ name ] = old[ name ];\n},\n\ncss: function( elem, name, force ) {\n\tif ( name == \"width\" || name == \"height\" ) {\n\t\tvar val, props = { position: \"absolute\", visibility: \"hidden\", display:\"block\" }, which = name == \"width\" ? [ \"Left\", \"Right\" ] : [ \"Top\", \"Bottom\" ];\n\n\t\tfunction getWH() {\n\t\t\tval = name == \"width\" ? elem.offsetWidth : elem.offsetHeight;\n\t\t\tvar padding = 0, border = 0;\n\t\t\tjQuery.each( which, function() {\n\t\t\t\tpadding += parseFloat(jQuery.curCSS( elem, \"padding\" + this, true)) || 0;\n\t\t\t\tborder += parseFloat(jQuery.curCSS( elem, \"border\" + this + \"Width\", true)) || 0;\n\t\t\t});\n\t\t\tval -= Math.round(padding + border);\n\t\t}\n\n\t\tif ( jQuery(elem).is(\":visible\") )\n\t\t\tgetWH();\n\t\telse\n\t\t\tjQuery.swap( elem, props, getWH );\n\n\t\treturn Math.max(0, val);\n\t}\n\n\treturn jQuery.curCSS( elem, name, force );\n},\n\ncurCSS: function( elem, name, force ) {\n\tvar ret, style = elem.style;\n\n\t// A helper method for determining if an element's values are broken\n\tfunction color( elem ) {\n\t\tif ( !jQuery.browser.safari )\n\t\t\treturn false;\n\n\t\t// defaultView is cached\n\t\tvar ret = defaultView.getComputedStyle( elem, null );\n\t\treturn !ret || ret.getPropertyValue(\"color\") == \"\";\n\t}\n\n\t// We need to handle opacity special in IE\n\tif ( name == \"opacity\" && jQuery.browser.msie ) {\n\t\tret = jQuery.attr( style, \"opacity\" );\n\n\t\treturn ret == \"\" ?\n\t\t\t\"1\" :\n\t\t\tret;\n\t}\n\t// Opera sometimes will give the wrong display answer, this fixes it, see #2037\n\tif ( jQuery.browser.opera && name == \"display\" ) {\n\t\tvar save = style.outline;\n\t\tstyle.outline = \"0 solid black\";\n\t\tstyle.outline = save;\n\t}\n\n\t// Make sure we're using the right name for getting the float value\n\tif ( name.match( /float/i ) )\n\t\tname = styleFloat;\n\n\tif ( !force && style && style[ name ] )\n\t\tret = style[ name ];\n\n\telse if ( defaultView.getComputedStyle ) {\n\n\t\t// Only \"float\" is needed here\n\t\tif ( name.match( /float/i ) )\n\t\t\tname = \"float\";\n\n\t\tname = name.replace( /([A-Z])/g, \"-$1\" ).toLowerCase();\n\n\t\tvar computedStyle = defaultView.getComputedStyle( elem, null );\n\n\t\tif ( computedStyle && !color( elem ) )\n\t\t\tret = computedStyle.getPropertyValue( name );\n\n\t\t// If the element isn't reporting its values properly in Safari\n\t\t// then some display: none elements are involved\n\t\telse {\n\t\t\tvar swap = [], stack = [], a = elem, i = 0;\n\n\t\t\t// Locate all of the parent display: none elements\n\t\t\tfor ( ; a && color(a); a = a.parentNode )\n\t\t\t\tstack.unshift(a);\n\n\t\t\t// Go through and make them visible, but in reverse\n\t\t\t// (It would be better if we knew the exact display type that they had)"}]},
{"id":"07a471ac45591a6685def61a7feca7dd1d565533","instances":[{"path":"./jquery-data/1.2.6/src/core.js","lines":[898,1063],"code":"\t\t\t// Finally, revert the display styles back\n\t\t\tfor ( i = 0; i < swap.length; i++ )\n\t\t\t\tif ( swap[ i ] != null )\n\t\t\t\t\tstack[ i ].style.display = swap[ i ];\n\t\t}\n\n\t\t// We should always get a number back from opacity\n\t\tif ( name == \"opacity\" && ret == \"\" )\n\t\t\tret = \"1\";\n\n\t} else if ( elem.currentStyle ) {\n\t\tvar camelCase = name.replace(/\\-(\\w)/g, function(all, letter){\n\t\t\treturn letter.toUpperCase();\n\t\t});\n\n\t\tret = elem.currentStyle[ name ] || elem.currentStyle[ camelCase ];\n\n\t\t// From the awesome hack by Dean Edwards\n\t\t// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n\n\t\t// If we're not dealing with a regular pixel number\n\t\t// but a number that has a weird ending, we need to convert it to pixels\n\t\tif ( !/^\\d+(px)?$/i.test( ret ) && /^\\d/.test( ret ) ) {\n\t\t\t// Remember the original values\n\t\t\tvar left = style.left, rsLeft = elem.runtimeStyle.left;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\telem.runtimeStyle.left = elem.currentStyle.left;\n\t\t\tstyle.left = ret || 0;\n\t\t\tret = style.pixelLeft + \"px\";\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.left = left;\n\t\t\telem.runtimeStyle.left = rsLeft;\n\t\t}\n\t}\n\n\treturn ret;\n},\n\nclean: function( elems, context ) {\n\tvar ret = [];\n\tcontext = context || document;\n\t// !context.createElement fails in IE with an error but returns typeof 'object'\n\tif (typeof context.createElement == 'undefined')\n\t\tcontext = context.ownerDocument || context[0] && context[0].ownerDocument || document;\n\n\tjQuery.each(elems, function(i, elem){\n\t\tif ( !elem )\n\t\t\treturn;\n\n\t\tif ( elem.constructor == Number )\n\t\t\telem += '';\n\n\t\t// Convert html string into DOM nodes\n\t\tif ( typeof elem == \"string\" ) {\n\t\t\t// Fix \"XHTML\"-style tags in all browsers\n\t\t\telem = elem.replace(/(<(\\w+)[^>]*?)\\/>/g, function(all, front, tag){\n\t\t\t\treturn tag.match(/^(abbr|br|col|img|input|link|meta|param|hr|area|embed)$/i) ?\n\t\t\t\t\tall :\n\t\t\t\t\tfront + \"></\" + tag + \">\";\n\t\t\t});\n\n\t\t\t// Trim whitespace, otherwise indexOf won't work as expected\n\t\t\tvar tags = jQuery.trim( elem ).toLowerCase(), div = context.createElement(\"div\");\n\n\t\t\tvar wrap =\n\t\t\t\t// option or optgroup\n\t\t\t\t!tags.indexOf(\"<opt\") &&\n\t\t\t\t[ 1, \"<select multiple='multiple'>\", \"</select>\" ] ||\n\n\t\t\t\t!tags.indexOf(\"<leg\") &&\n\t\t\t\t[ 1, \"<fieldset>\", \"</fieldset>\" ] ||\n\n\t\t\t\ttags.match(/^<(thead|tbody|tfoot|colg|cap)/) &&\n\t\t\t\t[ 1, \"<table>\", \"</table>\" ] ||\n\n\t\t\t\t!tags.indexOf(\"<tr\") &&\n\t\t\t\t[ 2, \"<table><tbody>\", \"</tbody></table>\" ] ||\n\n\t\t\t \t// <thead> matched above\n\t\t\t\t(!tags.indexOf(\"<td\") || !tags.indexOf(\"<th\")) &&\n\t\t\t\t[ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ] ||\n\n\t\t\t\t!tags.indexOf(\"<col\") &&\n\t\t\t\t[ 2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\" ] ||\n\n\t\t\t\t// IE can't serialize <link> and <script> tags normally\n\t\t\t\tjQuery.browser.msie &&\n\t\t\t\t[ 1, \"div<div>\", \"</div>\" ] ||\n\n\t\t\t\t[ 0, \"\", \"\" ];\n\n\t\t\t// Go to html and back, then peel off extra wrappers\n\t\t\tdiv.innerHTML = wrap[1] + elem + wrap[2];\n\n\t\t\t// Move to the right depth\n\t\t\twhile ( wrap[0]-- )\n\t\t\t\tdiv = div.lastChild;\n"},{"path":"./jquery-data/1.2.4/src/core.js","lines":[895,1060],"code":"\t\t\t// Finally, revert the display styles back\n\t\t\tfor ( i = 0; i < swap.length; i++ )\n\t\t\t\tif ( swap[ i ] != null )\n\t\t\t\t\tstack[ i ].style.display = swap[ i ];\n\t\t}\n\n\t\t// We should always get a number back from opacity\n\t\tif ( name == \"opacity\" && ret == \"\" )\n\t\t\tret = \"1\";\n\n\t} else if ( elem.currentStyle ) {\n\t\tvar camelCase = name.replace(/\\-(\\w)/g, function(all, letter){\n\t\t\treturn letter.toUpperCase();\n\t\t});\n\n\t\tret = elem.currentStyle[ name ] || elem.currentStyle[ camelCase ];\n\n\t\t// From the awesome hack by Dean Edwards\n\t\t// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n\n\t\t// If we're not dealing with a regular pixel number\n\t\t// but a number that has a weird ending, we need to convert it to pixels\n\t\tif ( !/^\\d+(px)?$/i.test( ret ) && /^\\d/.test( ret ) ) {\n\t\t\t// Remember the original values\n\t\t\tvar left = style.left, rsLeft = elem.runtimeStyle.left;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\telem.runtimeStyle.left = elem.currentStyle.left;\n\t\t\tstyle.left = ret || 0;\n\t\t\tret = style.pixelLeft + \"px\";\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.left = left;\n\t\t\telem.runtimeStyle.left = rsLeft;\n\t\t}\n\t}\n\n\treturn ret;\n},\n\nclean: function( elems, context ) {\n\tvar ret = [];\n\tcontext = context || document;\n\t// !context.createElement fails in IE with an error but returns typeof 'object'\n\tif (typeof context.createElement == 'undefined')\n\t\tcontext = context.ownerDocument || context[0] && context[0].ownerDocument || document;\n\n\tjQuery.each(elems, function(i, elem){\n\t\tif ( !elem )\n\t\t\treturn;\n\n\t\tif ( elem.constructor == Number )\n\t\t\telem += '';\n\n\t\t// Convert html string into DOM nodes\n\t\tif ( typeof elem == \"string\" ) {\n\t\t\t// Fix \"XHTML\"-style tags in all browsers\n\t\t\telem = elem.replace(/(<(\\w+)[^>]*?)\\/>/g, function(all, front, tag){\n\t\t\t\treturn tag.match(/^(abbr|br|col|img|input|link|meta|param|hr|area|embed)$/i) ?\n\t\t\t\t\tall :\n\t\t\t\t\tfront + \"></\" + tag + \">\";\n\t\t\t});\n\n\t\t\t// Trim whitespace, otherwise indexOf won't work as expected\n\t\t\tvar tags = jQuery.trim( elem ).toLowerCase(), div = context.createElement(\"div\");\n\n\t\t\tvar wrap =\n\t\t\t\t// option or optgroup\n\t\t\t\t!tags.indexOf(\"<opt\") &&\n\t\t\t\t[ 1, \"<select multiple='multiple'>\", \"</select>\" ] ||\n\n\t\t\t\t!tags.indexOf(\"<leg\") &&\n\t\t\t\t[ 1, \"<fieldset>\", \"</fieldset>\" ] ||\n\n\t\t\t\ttags.match(/^<(thead|tbody|tfoot|colg|cap)/) &&\n\t\t\t\t[ 1, \"<table>\", \"</table>\" ] ||\n\n\t\t\t\t!tags.indexOf(\"<tr\") &&\n\t\t\t\t[ 2, \"<table><tbody>\", \"</tbody></table>\" ] ||\n\n\t\t\t \t// <thead> matched above\n\t\t\t\t(!tags.indexOf(\"<td\") || !tags.indexOf(\"<th\")) &&\n\t\t\t\t[ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ] ||\n\n\t\t\t\t!tags.indexOf(\"<col\") &&\n\t\t\t\t[ 2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\" ] ||\n\n\t\t\t\t// IE can't serialize <link> and <script> tags normally\n\t\t\t\tjQuery.browser.msie &&\n\t\t\t\t[ 1, \"div<div>\", \"</div>\" ] ||\n\n\t\t\t\t[ 0, \"\", \"\" ];\n\n\t\t\t// Go to html and back, then peel off extra wrappers\n\t\t\tdiv.innerHTML = wrap[1] + elem + wrap[2];\n\n\t\t\t// Move to the right depth\n\t\t\twhile ( wrap[0]-- )\n\t\t\t\tdiv = div.lastChild;\n"}]},
{"id":"ff7871cba7374057b3e2712e52da0d7725fbf1a2","instances":[{"path":"./jquery-data/1.2.6/src/core.js","lines":[1063,1084],"code":"if ( name in elem && notxml && !special ) {\n\tif ( set ){\n\t\t// We can't allow the type property to be changed (since it causes problems in IE)\n\t\tif ( name == \"type\" && jQuery.nodeName( elem, \"input\" ) && elem.parentNode )\n\t\t\tthrow \"type property can't be changed\";\n\n\t\telem[ name ] = value;\n\t}\n\n\t// browsers index elements by id/name on forms, give priority to attributes.\n\tif( jQuery.nodeName( elem, \"form\" ) && elem.getAttributeNode(name) )\n\t\treturn elem.getAttributeNode( name ).nodeValue;\n\n\treturn elem[ name ];\n}\n\nif ( msie && notxml &&  name == \"style\" )\n\treturn jQuery.attr( elem.style, \"cssText\", value );\n\nif ( set )\n\t// convert the value to a string (all browsers do this but IE) see #1070\n\telem.setAttribute( name, \"\" + value );"},{"path":"./jquery-data/1.2.4/src/core.js","lines":[1060,1081],"code":"if ( notxml && !special && name in elem ) {\n\tif ( set ){\n\t\t// We can't allow the type property to be changed (since it causes problems in IE)\n\t\tif ( name == \"type\" && jQuery.nodeName( elem, \"input\" ) && elem.parentNode )\n\t\t\tthrow \"type property can't be changed\";\n\n\t\telem[ name ] = value;\n\t}\n\n\t// browsers index elements by id/name on forms, give priority to attributes.\n\tif( jQuery.nodeName( elem, \"form\" ) && elem.getAttributeNode(name) )\n\t\treturn elem.getAttributeNode( name ).nodeValue;\n\n\treturn elem[ name ];\n}\n\nif ( msie && notxml &&  name == \"style\" )\n\treturn jQuery.attr( elem.style, \"cssText\", value );\n\nif ( set )\n\t// convert the value to a string (all browsers do this but IE) see #1070\n\telem.setAttribute( name, \"\" + value );"}]},
{"id":"b8fe24ece140965fc415a727142e972f504e1204","instances":[{"path":"./jquery-data/1.2.6/src/core.js","lines":[1098,1370],"code":"\t\tif ( msie && name == \"opacity\" ) {\n\t\t\tif ( set ) {\n\t\t\t\t// IE has trouble with opacity if it does not have layout\n\t\t\t\t// Force it by setting the zoom level\n\t\t\t\telem.zoom = 1;\n\n\t\t\t\t// Set the alpha filter to set the opacity\n\t\t\t\telem.filter = (elem.filter || \"\").replace( /alpha\\([^)]*\\)/, \"\" ) +\n\t\t\t\t\t(parseInt( value ) + '' == \"NaN\" ? \"\" : \"alpha(opacity=\" + value * 100 + \")\");\n\t\t\t}\n\n\t\t\treturn elem.filter && elem.filter.indexOf(\"opacity=\") >= 0 ?\n\t\t\t\t(parseFloat( elem.filter.match(/opacity=([^)]*)/)[1] ) / 100) + '':\n\t\t\t\t\"\";\n\t\t}\n\n\t\tname = name.replace(/-([a-z])/ig, function(all, letter){\n\t\t\treturn letter.toUpperCase();\n\t\t});\n\n\t\tif ( set )\n\t\t\telem[ name ] = value;\n\n\t\treturn elem[ name ];\n\t},\n\n\ttrim: function( text ) {\n\t\treturn (text || \"\").replace( /^\\s+|\\s+$/g, \"\" );\n\t},\n\n\tmakeArray: function( array ) {\n\t\tvar ret = [];\n\n\t\tif( array != null ){\n\t\t\tvar i = array.length;\n\t\t\t//the window, strings and functions also have 'length'\n\t\t\tif( i == null || array.split || array.setInterval || array.call )\n\t\t\t\tret[0] = array;\n\t\t\telse\n\t\t\t\twhile( i )\n\t\t\t\t\tret[--i] = array[i];\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, array ) {\n\t\tfor ( var i = 0, length = array.length; i < length; i++ )\n\t\t// Use === because on IE, window == document\n\t\t\tif ( array[ i ] === elem )\n\t\t\t\treturn i;\n\n\t\treturn -1;\n\t},\n\n\tmerge: function( first, second ) {\n\t\t// We have to loop this way because IE & Opera overwrite the length\n\t\t// expando of getElementsByTagName\n\t\tvar i = 0, elem, pos = first.length;\n\t\t// Also, we need to make sure that the correct elements are being returned\n\t\t// (IE returns comment nodes in a '*' query)\n\t\tif ( jQuery.browser.msie ) {\n\t\t\twhile ( elem = second[ i++ ] )\n\t\t\t\tif ( elem.nodeType != 8 )\n\t\t\t\t\tfirst[ pos++ ] = elem;\n\n\t\t} else\n\t\t\twhile ( elem = second[ i++ ] )\n\t\t\t\tfirst[ pos++ ] = elem;\n\n\t\treturn first;\n\t},\n\n\tunique: function( array ) {\n\t\tvar ret = [], done = {};\n\n\t\ttry {\n\n\t\t\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\t\t\tvar id = jQuery.data( array[ i ] );\n\n\t\t\t\tif ( !done[ id ] ) {\n\t\t\t\t\tdone[ id ] = true;\n\t\t\t\t\tret.push( array[ i ] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch( e ) {\n\t\t\tret = array;\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tgrep: function( elems, callback, inv ) {\n\t\tvar ret = [];\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( var i = 0, length = elems.length; i < length; i++ )"},{"path":"./jquery-data/1.2.4/src/core.js","lines":[1093,1365],"code":"\t\tif ( msie && name == \"opacity\" ) {\n\t\t\tif ( set ) {\n\t\t\t\t// IE has trouble with opacity if it does not have layout\n\t\t\t\t// Force it by setting the zoom level\n\t\t\t\telem.zoom = 1;\n\n\t\t\t\t// Set the alpha filter to set the opacity\n\t\t\t\telem.filter = (elem.filter || \"\").replace( /alpha\\([^)]*\\)/, \"\" ) +\n\t\t\t\t\t(parseInt( value ) + '' == \"NaN\" ? \"\" : \"alpha(opacity=\" + value * 100 + \")\");\n\t\t\t}\n\n\t\t\treturn elem.filter && elem.filter.indexOf(\"opacity=\") >= 0 ?\n\t\t\t\t(parseFloat( elem.filter.match(/opacity=([^)]*)/)[1] ) / 100) + '':\n\t\t\t\t\"\";\n\t\t}\n\n\t\tname = name.replace(/-([a-z])/ig, function(all, letter){\n\t\t\treturn letter.toUpperCase();\n\t\t});\n\n\t\tif ( set )\n\t\t\telem[ name ] = value;\n\n\t\treturn elem[ name ];\n\t},\n\n\ttrim: function( text ) {\n\t\treturn (text || \"\").replace( /^\\s+|\\s+$/g, \"\" );\n\t},\n\n\tmakeArray: function( array ) {\n\t\tvar ret = [];\n\n\t\tif( array != null ){\n\t\t\tvar i = array.length;\n\t\t\t//the window, strings and functions also have 'length'\n\t\t\tif( i == null || array.split || array.setInterval || array.call )\n\t\t\t\tret[0] = array;\n\t\t\telse\n\t\t\t\twhile( i )\n\t\t\t\t\tret[--i] = array[i];\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, array ) {\n\t\tfor ( var i = 0, length = array.length; i < length; i++ )\n\t\t// Use === because on IE, window == document\n\t\t\tif ( array[ i ] === elem )\n\t\t\t\treturn i;\n\n\t\treturn -1;\n\t},\n\n\tmerge: function( first, second ) {\n\t\t// We have to loop this way because IE & Opera overwrite the length\n\t\t// expando of getElementsByTagName\n\t\tvar i = 0, elem, pos = first.length;\n\t\t// Also, we need to make sure that the correct elements are being returned\n\t\t// (IE returns comment nodes in a '*' query)\n\t\tif ( jQuery.browser.msie ) {\n\t\t\twhile ( elem = second[ i++ ] )\n\t\t\t\tif ( elem.nodeType != 8 )\n\t\t\t\t\tfirst[ pos++ ] = elem;\n\n\t\t} else\n\t\t\twhile ( elem = second[ i++ ] )\n\t\t\t\tfirst[ pos++ ] = elem;\n\n\t\treturn first;\n\t},\n\n\tunique: function( array ) {\n\t\tvar ret = [], done = {};\n\n\t\ttry {\n\n\t\t\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\t\t\tvar id = jQuery.data( array[ i ] );\n\n\t\t\t\tif ( !done[ id ] ) {\n\t\t\t\t\tdone[ id ] = true;\n\t\t\t\t\tret.push( array[ i ] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch( e ) {\n\t\t\tret = array;\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tgrep: function( elems, callback, inv ) {\n\t\tvar ret = [];\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( var i = 0, length = elems.length; i < length; i++ )"}]},
{"id":"767becadc08bfce0bd90a8298b9bd2548b390089","instances":[{"path":"./jquery-data/1.2.6/src/dimensions.js","lines":[1,20],"code":"// Create innerHeight, innerWidth, outerHeight and outerWidth methods\njQuery.each([ \"Height\", \"Width\" ], function(i, name){\n\n\tvar tl = i ? \"Left\"  : \"Top\",  // top or left\n\t\tbr = i ? \"Right\" : \"Bottom\"; // bottom or right\n\n\t// innerHeight and innerWidth\n\tjQuery.fn[\"inner\" + name] = function(){\n\t\treturn this[ name.toLowerCase() ]() +\n\t\t\tnum(this, \"padding\" + tl) +\n\t\t\tnum(this, \"padding\" + br);\n\t};\n\n\t// outerHeight and outerWidth\n\tjQuery.fn[\"outer\" + name] = function(margin) {\n\t\treturn this[\"inner\" + name]() +\n\t\t\tnum(this, \"border\" + tl + \"Width\") +\n\t\t\tnum(this, \"border\" + br + \"Width\") +\n\t\t\t(margin ?\n\t\t\t\tnum(this, \"margin\" + tl) + num(this, \"margin\" + br) : 0);"},{"path":"./jquery-data/1.2.4/src/dimensions.js","lines":[1,20],"code":"// Create innerHeight, innerWidth, outerHeight and outerWidth methods\njQuery.each([ \"Height\", \"Width\" ], function(i, name){\n\n\tvar tl = i ? \"Left\"  : \"Top\",  // top or left\n\t\tbr = i ? \"Right\" : \"Bottom\"; // bottom or right\n\n\t// innerHeight and innerWidth\n\tjQuery.fn[\"inner\" + name] = function(){\n\t\treturn this[ name.toLowerCase() ]() +\n\t\t\tnum(this, \"padding\" + tl) +\n\t\t\tnum(this, \"padding\" + br);\n\t};\n\n\t// outerHeight and outerWidth\n\tjQuery.fn[\"outer\" + name] = function(margin) {\n\t\treturn this[\"inner\" + name]() +\n\t\t\tnum(this, \"border\" + tl + \"Width\") +\n\t\t\tnum(this, \"border\" + br + \"Width\") +\n\t\t\t(margin ?\n\t\t\t\tnum(this, \"margin\" + tl) + num(this, \"margin\" + br) : 0);"}]},
{"id":"9e8e0c704e60952c073151a0a3158ddbeee72678","instances":[{"path":"./jquery-data/1.2.6/src/offset.js","lines":[1,167],"code":"// The Offset Method\n// Originally By Brandon Aaron, part of the Dimension Plugin\n// http://jquery.com/plugins/project/dimensions\njQuery.fn.offset = function() {\n\tvar left = 0, top = 0, elem = this[0], results;\n\n\tif ( elem ) with ( jQuery.browser ) {\n\t\tvar parent       = elem.parentNode,\n\t\t    offsetChild  = elem,\n\t\t    offsetParent = elem.offsetParent,\n\t\t    doc          = elem.ownerDocument,\n\t\t    safari2      = safari && parseInt(version) < 522 && !/adobeair/i.test(userAgent),\n\t\t    css          = jQuery.curCSS,\n\t\t    fixed        = css(elem, \"position\") == \"fixed\";\n\n\t\t// Use getBoundingClientRect if available\n\t\tif ( elem.getBoundingClientRect ) {\n\t\t\tvar box = elem.getBoundingClientRect();\n\n\t\t\t// Add the document scroll offsets\n\t\t\tadd(box.left + Math.max(doc.documentElement.scrollLeft, doc.body.scrollLeft),\n\t\t\t\tbox.top  + Math.max(doc.documentElement.scrollTop,  doc.body.scrollTop));\n\n\t\t\t// IE adds the HTML element's border, by default it is medium which is 2px\n\t\t\t// IE 6 and 7 quirks mode the border width is overwritable by the following css html { border: 0; }\n\t\t\t// IE 7 standards mode, the border is always 2px\n\t\t\t// This border/offset is typically represented by the clientLeft and clientTop properties\n\t\t\t// However, in IE6 and 7 quirks mode the clientLeft and clientTop properties are not updated when overwriting it via CSS\n\t\t\t// Therefore this method will be off by 2px in IE while in quirksmode\n\t\t\tadd( -doc.documentElement.clientLeft, -doc.documentElement.clientTop );\n\n\t\t// Otherwise loop through the offsetParents and parentNodes\n\t\t} else {\n\n\t\t\t// Initial element offsets\n\t\t\tadd( elem.offsetLeft, elem.offsetTop );\n\n\t\t\t// Get parent offsets\n\t\t\twhile ( offsetParent ) {\n\t\t\t\t// Add offsetParent offsets\n\t\t\t\tadd( offsetParent.offsetLeft, offsetParent.offsetTop );\n\n\t\t\t\t// Mozilla and Safari > 2 does not include the border on offset parents\n\t\t\t\t// However Mozilla adds the border for table or table cells\n\t\t\t\tif ( mozilla && !/^t(able|d|h)$/i.test(offsetParent.tagName) || safari && !safari2 )\n\t\t\t\t\tborder( offsetParent );\n\n\t\t\t\t// Add the document scroll offsets if position is fixed on any offsetParent\n\t\t\t\tif ( !fixed && css(offsetParent, \"position\") == \"fixed\" )\n\t\t\t\t\tfixed = true;\n\n\t\t\t\t// Set offsetChild to previous offsetParent unless it is the body element\n\t\t\t\toffsetChild  = /^body$/i.test(offsetParent.tagName) ? offsetChild : offsetParent;\n\t\t\t\t// Get next offsetParent\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\t// Get parent scroll offsets\n\t\t\twhile ( parent && parent.tagName && !/^body|html$/i.test(parent.tagName) ) {\n\t\t\t\t// Remove parent scroll UNLESS that parent is inline or a table to work around Opera inline/table scrollLeft/Top bug\n\t\t\t\tif ( !/^inline|table.*$/i.test(css(parent, \"display\")) )\n\t\t\t\t\t// Subtract parent scroll offsets\n\t\t\t\t\tadd( -parent.scrollLeft, -parent.scrollTop );\n\n\t\t\t\t// Mozilla does not add the border for a parent that has overflow != visible\n\t\t\t\tif ( mozilla && css(parent, \"overflow\") != \"visible\" )\n\t\t\t\t\tborder( parent );\n\n\t\t\t\t// Get next parent\n\t\t\t\tparent = parent.parentNode;\n\t\t\t}\n\n\t\t\t// Safari <= 2 doubles body offsets with a fixed position element/offsetParent or absolutely positioned offsetChild\n\t\t\t// Mozilla doubles body offsets with a non-absolutely positioned offsetChild\n\t\t\tif ( (safari2 && (fixed || css(offsetChild, \"position\") == \"absolute\")) ||\n\t\t\t\t(mozilla && css(offsetChild, \"position\") != \"absolute\") )\n\t\t\t\t\tadd( -doc.body.offsetLeft, -doc.body.offsetTop );\n\n\t\t\t// Add the document scroll offsets if position is fixed\n\t\t\tif ( fixed )\n\t\t\t\tadd(Math.max(doc.documentElement.scrollLeft, doc.body.scrollLeft),\n\t\t\t\t\tMath.max(doc.documentElement.scrollTop,  doc.body.scrollTop));\n\t\t}\n\n\t\t// Return an object with top and left properties\n\t\tresults = { top: top, left: left };\n\t}\n\n\tfunction border(elem) {\n\t\tadd( jQuery.curCSS(elem, \"borderLeftWidth\", true), jQuery.curCSS(elem, \"borderTopWidth\", true) );\n\t}\n\n\tfunction add(l, t) {\n\t\tleft += parseInt(l, 10) || 0;\n\t\ttop += parseInt(t, 10) || 0;\n\t}\n\n\treturn results;\n};\n"},{"path":"./jquery-data/1.2.4/src/offset.js","lines":[1,167],"code":"// The Offset Method\n// Originally By Brandon Aaron, part of the Dimension Plugin\n// http://jquery.com/plugins/project/dimensions\njQuery.fn.offset = function() {\n\tvar left = 0, top = 0, elem = this[0], results;\n\n\tif ( elem ) with ( jQuery.browser ) {\n\t\tvar parent       = elem.parentNode,\n\t\t    offsetChild  = elem,\n\t\t    offsetParent = elem.offsetParent,\n\t\t    doc          = elem.ownerDocument,\n\t\t    safari2      = safari && parseInt(version) < 522 && !/adobeair/i.test(userAgent),\n\t\t    css          = jQuery.curCSS,\n\t\t    fixed        = css(elem, \"position\") == \"fixed\";\n\n\t\t// Use getBoundingClientRect if available\n\t\tif ( elem.getBoundingClientRect ) {\n\t\t\tvar box = elem.getBoundingClientRect();\n\n\t\t\t// Add the document scroll offsets\n\t\t\tadd(box.left + Math.max(doc.documentElement.scrollLeft, doc.body.scrollLeft),\n\t\t\t\tbox.top  + Math.max(doc.documentElement.scrollTop,  doc.body.scrollTop));\n\n\t\t\t// IE adds the HTML element's border, by default it is medium which is 2px\n\t\t\t// IE 6 and 7 quirks mode the border width is overwritable by the following css html { border: 0; }\n\t\t\t// IE 7 standards mode, the border is always 2px\n\t\t\t// This border/offset is typically represented by the clientLeft and clientTop properties\n\t\t\t// However, in IE6 and 7 quirks mode the clientLeft and clientTop properties are not updated when overwriting it via CSS\n\t\t\t// Therefore this method will be off by 2px in IE while in quirksmode\n\t\t\tadd( -doc.documentElement.clientLeft, -doc.documentElement.clientTop );\n\n\t\t// Otherwise loop through the offsetParents and parentNodes\n\t\t} else {\n\n\t\t\t// Initial element offsets\n\t\t\tadd( elem.offsetLeft, elem.offsetTop );\n\n\t\t\t// Get parent offsets\n\t\t\twhile ( offsetParent ) {\n\t\t\t\t// Add offsetParent offsets\n\t\t\t\tadd( offsetParent.offsetLeft, offsetParent.offsetTop );\n\n\t\t\t\t// Mozilla and Safari > 2 does not include the border on offset parents\n\t\t\t\t// However Mozilla adds the border for table or table cells\n\t\t\t\tif ( mozilla && !/^t(able|d|h)$/i.test(offsetParent.tagName) || safari && !safari2 )\n\t\t\t\t\tborder( offsetParent );\n\n\t\t\t\t// Add the document scroll offsets if position is fixed on any offsetParent\n\t\t\t\tif ( !fixed && css(offsetParent, \"position\") == \"fixed\" )\n\t\t\t\t\tfixed = true;\n\n\t\t\t\t// Set offsetChild to previous offsetParent unless it is the body element\n\t\t\t\toffsetChild  = /^body$/i.test(offsetParent.tagName) ? offsetChild : offsetParent;\n\t\t\t\t// Get next offsetParent\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\t// Get parent scroll offsets\n\t\t\twhile ( parent && parent.tagName && !/^body|html$/i.test(parent.tagName) ) {\n\t\t\t\t// Remove parent scroll UNLESS that parent is inline or a table to work around Opera inline/table scrollLeft/Top bug\n\t\t\t\tif ( !/^inline|table.*$/i.test(css(parent, \"display\")) )\n\t\t\t\t\t// Subtract parent scroll offsets\n\t\t\t\t\tadd( -parent.scrollLeft, -parent.scrollTop );\n\n\t\t\t\t// Mozilla does not add the border for a parent that has overflow != visible\n\t\t\t\tif ( mozilla && css(parent, \"overflow\") != \"visible\" )\n\t\t\t\t\tborder( parent );\n\n\t\t\t\t// Get next parent\n\t\t\t\tparent = parent.parentNode;\n\t\t\t}\n\n\t\t\t// Safari <= 2 doubles body offsets with a fixed position element/offsetParent or absolutely positioned offsetChild\n\t\t\t// Mozilla doubles body offsets with a non-absolutely positioned offsetChild\n\t\t\tif ( (safari2 && (fixed || css(offsetChild, \"position\") == \"absolute\")) ||\n\t\t\t\t(mozilla && css(offsetChild, \"position\") != \"absolute\") )\n\t\t\t\t\tadd( -doc.body.offsetLeft, -doc.body.offsetTop );\n\n\t\t\t// Add the document scroll offsets if position is fixed\n\t\t\tif ( fixed )\n\t\t\t\tadd(Math.max(doc.documentElement.scrollLeft, doc.body.scrollLeft),\n\t\t\t\t\tMath.max(doc.documentElement.scrollTop,  doc.body.scrollTop));\n\t\t}\n\n\t\t// Return an object with top and left properties\n\t\tresults = { top: top, left: left };\n\t}\n\n\tfunction border(elem) {\n\t\tadd( jQuery.curCSS(elem, \"borderLeftWidth\", true), jQuery.curCSS(elem, \"borderTopWidth\", true) );\n\t}\n\n\tfunction add(l, t) {\n\t\tleft += parseInt(l, 10) || 0;\n\t\ttop += parseInt(t, 10) || 0;\n\t}\n\n\treturn results;\n};\n"}]},
{"id":"849468afc09afc0bb797b2f7d1135901f58bf314","instances":[{"path":"./jquery-data/1.2.6/src/selector.js","lines":[1,131],"code":"var chars = jQuery.browser.safari && parseInt(jQuery.browser.version) < 417 ?\n\t\t\"(?:[\\\\w*_-]|\\\\\\\\.)\" :\n\t\t\"(?:[\\\\w\\u0128-\\uFFFF*_-]|\\\\\\\\.)\",\n\tquickChild = new RegExp(\"^>\\\\s*(\" + chars + \"+)\"),\n\tquickID = new RegExp(\"^(\" + chars + \"+)(#)(\" + chars + \"+)\"),\n\tquickClass = new RegExp(\"^([#.]?)(\" + chars + \"*)\");\n\njQuery.extend({\n\texpr: {\n\t\t\"\": function(a,i,m){return m[2]==\"*\"||jQuery.nodeName(a,m[2]);},\n\t\t\"#\": function(a,i,m){return a.getAttribute(\"id\")==m[2];},\n\t\t\":\": {\n\t\t\t// Position Checks\n\t\t\tlt: function(a,i,m){return i<m[3]-0;},\n\t\t\tgt: function(a,i,m){return i>m[3]-0;},\n\t\t\tnth: function(a,i,m){return m[3]-0==i;},\n\t\t\teq: function(a,i,m){return m[3]-0==i;},\n\t\t\tfirst: function(a,i){return i==0;},\n\t\t\tlast: function(a,i,m,r){return i==r.length-1;},\n\t\t\teven: function(a,i){return i%2==0;},\n\t\t\todd: function(a,i){return i%2;},\n\n\t\t\t// Child Checks\n\t\t\t\"first-child\": function(a){return a.parentNode.getElementsByTagName(\"*\")[0]==a;},\n\t\t\t\"last-child\": function(a){return jQuery.nth(a.parentNode.lastChild,1,\"previousSibling\")==a;},\n\t\t\t\"only-child\": function(a){return !jQuery.nth(a.parentNode.lastChild,2,\"previousSibling\");},\n\n\t\t\t// Parent Checks\n\t\t\tparent: function(a){return a.firstChild;},\n\t\t\tempty: function(a){return !a.firstChild;},\n\n\t\t\t// Text Check\n\t\t\tcontains: function(a,i,m){return (a.textContent||a.innerText||jQuery(a).text()||\"\").indexOf(m[3])>=0;},\n\n\t\t\t// Visibility\n\t\t\tvisible: function(a){return \"hidden\"!=a.type&&jQuery.css(a,\"display\")!=\"none\"&&jQuery.css(a,\"visibility\")!=\"hidden\";},\n\t\t\thidden: function(a){return \"hidden\"==a.type||jQuery.css(a,\"display\")==\"none\"||jQuery.css(a,\"visibility\")==\"hidden\";},\n\n\t\t\t// Form attributes\n\t\t\tenabled: function(a){return !a.disabled;},\n\t\t\tdisabled: function(a){return a.disabled;},\n\t\t\tchecked: function(a){return a.checked;},\n\t\t\tselected: function(a){return a.selected||jQuery.attr(a,\"selected\");},\n\n\t\t\t// Form elements\n\t\t\ttext: function(a){return \"text\"==a.type;},\n\t\t\tradio: function(a){return \"radio\"==a.type;},\n\t\t\tcheckbox: function(a){return \"checkbox\"==a.type;},\n\t\t\tfile: function(a){return \"file\"==a.type;},\n\t\t\tpassword: function(a){return \"password\"==a.type;},\n\t\t\tsubmit: function(a){return \"submit\"==a.type;},\n\t\t\timage: function(a){return \"image\"==a.type;},\n\t\t\treset: function(a){return \"reset\"==a.type;},\n\t\t\tbutton: function(a){return \"button\"==a.type||jQuery.nodeName(a,\"button\");},\n\t\t\tinput: function(a){return /input|select|textarea|button/i.test(a.nodeName);},\n\n\t\t\t// :has()\n\t\t\thas: function(a,i,m){return jQuery.find(m[3],a).length;},\n\n\t\t\t// :header\n\t\t\theader: function(a){return /h\\d/i.test(a.nodeName);},\n\n\t\t\t// :animated\n\t\t\tanimated: function(a){return jQuery.grep(jQuery.timers,function(fn){return a==fn.elem;}).length;}\n\t\t}\n\t},\n\n\t// The regular expressions that power the parsing engine\n\tparse: [\n\t\t// Match: [@value='test'], [@foo]\n\t\t/^(\\[) *@?([\\w-]+) *([!*$^~=]*) *('?\"?)(.*?)\\4 *\\]/,\n\n\t\t// Match: :contains('foo')\n\t\t/^(:)([\\w-]+)\\(\"?'?(.*?(\\(.*?\\))?[^(]*?)\"?'?\\)/,\n\n\t\t// Match: :even, :last-child, #id, .class\n\t\tnew RegExp(\"^([:.#]*)(\" + chars + \"+)\")\n\t],\n\n\tmultiFilter: function( expr, elems, not ) {\n\t\tvar old, cur = [];\n\n\t\twhile ( expr && expr != old ) {\n\t\t\told = expr;\n\t\t\tvar f = jQuery.filter( expr, elems, not );\n\t\t\texpr = f.t.replace(/^\\s*,\\s*/, \"\" );\n\t\t\tcur = not ? elems = f.r : jQuery.merge( cur, f.r );\n\t\t}\n\n\t\treturn cur;\n\t},\n\n\tfind: function( t, context ) {\n\t\t// Quickly handle non-string expressions\n\t\tif ( typeof t != \"string\" )\n\t\t\treturn [ t ];\n\n\t\t// check to make sure context is a DOM element or a document\n\t\tif ( context && context.nodeType != 1 && context.nodeType != 9)\n\t\t\treturn [ ];"},{"path":"./jquery-data/1.2.4/src/selector.js","lines":[1,131],"code":"var chars = jQuery.browser.safari && parseInt(jQuery.browser.version) < 417 ?\n\t\t\"(?:[\\\\w*_-]|\\\\\\\\.)\" :\n\t\t\"(?:[\\\\w\\u0128-\\uFFFF*_-]|\\\\\\\\.)\",\n\tquickChild = new RegExp(\"^>\\\\s*(\" + chars + \"+)\"),\n\tquickID = new RegExp(\"^(\" + chars + \"+)(#)(\" + chars + \"+)\"),\n\tquickClass = new RegExp(\"^([#.]?)(\" + chars + \"*)\");\n\njQuery.extend({\n\texpr: {\n\t\t\"\": function(a,i,m){return m[2]==\"*\"||jQuery.nodeName(a,m[2]);},\n\t\t\"#\": function(a,i,m){return a.getAttribute(\"id\")==m[2];},\n\t\t\":\": {\n\t\t\t// Position Checks\n\t\t\tlt: function(a,i,m){return i<m[3]-0;},\n\t\t\tgt: function(a,i,m){return i>m[3]-0;},\n\t\t\tnth: function(a,i,m){return m[3]-0==i;},\n\t\t\teq: function(a,i,m){return m[3]-0==i;},\n\t\t\tfirst: function(a,i){return i==0;},\n\t\t\tlast: function(a,i,m,r){return i==r.length-1;},\n\t\t\teven: function(a,i){return i%2==0;},\n\t\t\todd: function(a,i){return i%2;},\n\n\t\t\t// Child Checks\n\t\t\t\"first-child\": function(a){return a.parentNode.getElementsByTagName(\"*\")[0]==a;},\n\t\t\t\"last-child\": function(a){return jQuery.nth(a.parentNode.lastChild,1,\"previousSibling\")==a;},\n\t\t\t\"only-child\": function(a){return !jQuery.nth(a.parentNode.lastChild,2,\"previousSibling\");},\n\n\t\t\t// Parent Checks\n\t\t\tparent: function(a){return a.firstChild;},\n\t\t\tempty: function(a){return !a.firstChild;},\n\n\t\t\t// Text Check\n\t\t\tcontains: function(a,i,m){return (a.textContent||a.innerText||jQuery(a).text()||\"\").indexOf(m[3])>=0;},\n\n\t\t\t// Visibility\n\t\t\tvisible: function(a){return \"hidden\"!=a.type&&jQuery.css(a,\"display\")!=\"none\"&&jQuery.css(a,\"visibility\")!=\"hidden\";},\n\t\t\thidden: function(a){return \"hidden\"==a.type||jQuery.css(a,\"display\")==\"none\"||jQuery.css(a,\"visibility\")==\"hidden\";},\n\n\t\t\t// Form attributes\n\t\t\tenabled: function(a){return !a.disabled;},\n\t\t\tdisabled: function(a){return a.disabled;},\n\t\t\tchecked: function(a){return a.checked;},\n\t\t\tselected: function(a){return a.selected||jQuery.attr(a,\"selected\");},\n\n\t\t\t// Form elements\n\t\t\ttext: function(a){return \"text\"==a.type;},\n\t\t\tradio: function(a){return \"radio\"==a.type;},\n\t\t\tcheckbox: function(a){return \"checkbox\"==a.type;},\n\t\t\tfile: function(a){return \"file\"==a.type;},\n\t\t\tpassword: function(a){return \"password\"==a.type;},\n\t\t\tsubmit: function(a){return \"submit\"==a.type;},\n\t\t\timage: function(a){return \"image\"==a.type;},\n\t\t\treset: function(a){return \"reset\"==a.type;},\n\t\t\tbutton: function(a){return \"button\"==a.type||jQuery.nodeName(a,\"button\");},\n\t\t\tinput: function(a){return /input|select|textarea|button/i.test(a.nodeName);},\n\n\t\t\t// :has()\n\t\t\thas: function(a,i,m){return jQuery.find(m[3],a).length;},\n\n\t\t\t// :header\n\t\t\theader: function(a){return /h\\d/i.test(a.nodeName);},\n\n\t\t\t// :animated\n\t\t\tanimated: function(a){return jQuery.grep(jQuery.timers,function(fn){return a==fn.elem;}).length;}\n\t\t}\n\t},\n\n\t// The regular expressions that power the parsing engine\n\tparse: [\n\t\t// Match: [@value='test'], [@foo]\n\t\t/^(\\[) *@?([\\w-]+) *([!*$^~=]*) *('?\"?)(.*?)\\4 *\\]/,\n\n\t\t// Match: :contains('foo')\n\t\t/^(:)([\\w-]+)\\(\"?'?(.*?(\\(.*?\\))?[^(]*?)\"?'?\\)/,\n\n\t\t// Match: :even, :last-child, #id, .class\n\t\tnew RegExp(\"^([:.#]*)(\" + chars + \"+)\")\n\t],\n\n\tmultiFilter: function( expr, elems, not ) {\n\t\tvar old, cur = [];\n\n\t\twhile ( expr && expr != old ) {\n\t\t\told = expr;\n\t\t\tvar f = jQuery.filter( expr, elems, not );\n\t\t\texpr = f.t.replace(/^\\s*,\\s*/, \"\" );\n\t\t\tcur = not ? elems = f.r : jQuery.merge( cur, f.r );\n\t\t}\n\n\t\treturn cur;\n\t},\n\n\tfind: function( t, context ) {\n\t\t// Quickly handle non-string expressions\n\t\tif ( typeof t != \"string\" )\n\t\t\treturn [ t ];\n\n\t\t// check to make sure context is a DOM element or a document\n\t\tif ( context && context.nodeType != 1 && context.nodeType != 9)\n\t\t\treturn [ ];"}]},
{"id":"debb488996ef4dcd5852184bfee28673aa9f17ec","instances":[{"path":"./jquery-data/1.2.6/src/selector.js","lines":[127,443],"code":"\t\t\t// Perform our own iteration and filter\n\t\t\tfor ( var i = 0; ret[i]; i++ )\n\t\t\t\tfor ( var c = ret[i].firstChild; c; c = c.nextSibling )\n\t\t\t\t\tif ( c.nodeType == 1 && (nodeName == \"*\" || c.nodeName.toUpperCase() == nodeName) )\n\t\t\t\t\t\tr.push( c );\n\n\t\t\tret = r;\n\t\t\tt = t.replace( re, \"\" );\n\t\t\tif ( t.indexOf(\" \") == 0 ) continue;\n\t\t\tfoundToken = true;\n\t\t} else {\n\t\t\tre = /^([>+~])\\s*(\\w*)/i;\n\n\t\t\tif ( (m = re.exec(t)) != null ) {\n\t\t\t\tr = [];\n\n\t\t\t\tvar merge = {};\n\t\t\t\tnodeName = m[2].toUpperCase();\n\t\t\t\tm = m[1];\n\n\t\t\t\tfor ( var j = 0, rl = ret.length; j < rl; j++ ) {\n\t\t\t\t\tvar n = m == \"~\" || m == \"+\" ? ret[j].nextSibling : ret[j].firstChild;\n\t\t\t\t\tfor ( ; n; n = n.nextSibling )\n\t\t\t\t\t\tif ( n.nodeType == 1 ) {\n\t\t\t\t\t\t\tvar id = jQuery.data(n);\n\n\t\t\t\t\t\t\tif ( m == \"~\" && merge[id] ) break;\n\n\t\t\t\t\t\t\tif (!nodeName || n.nodeName.toUpperCase() == nodeName ) {\n\t\t\t\t\t\t\t\tif ( m == \"~\" ) merge[id] = true;\n\t\t\t\t\t\t\t\tr.push( n );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( m == \"+\" ) break;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tret = r;\n\n\t\t\t\t// And remove the token\n\t\t\t\tt = jQuery.trim( t.replace( re, \"\" ) );\n\t\t\t\tfoundToken = true;\n\t\t\t}\n\t\t}\n\n\t\t// See if there's still an expression, and that we haven't already\n\t\t// matched a token\n\t\tif ( t && !foundToken ) {\n\t\t\t// Handle multiple expressions\n\t\t\tif ( !t.indexOf(\",\") ) {\n\t\t\t\t// Clean the result set\n\t\t\t\tif ( context == ret[0] ) ret.shift();\n\n\t\t\t\t// Merge the result sets\n\t\t\t\tdone = jQuery.merge( done, ret );\n\n\t\t\t\t// Reset the context\n\t\t\t\tr = ret = [context];\n\n\t\t\t\t// Touch up the selector string\n\t\t\t\tt = \" \" + t.substr(1,t.length);\n\n\t\t\t} else {\n\t\t\t\t// Optimize for the case nodeName#idName\n\t\t\t\tvar re2 = quickID;\n\t\t\t\tvar m = re2.exec(t);\n\n\t\t\t\t// Re-organize the results, so that they're consistent\n\t\t\t\tif ( m ) {\n\t\t\t\t\tm = [ 0, m[2], m[3], m[1] ];\n\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, do a traditional filter check for\n\t\t\t\t\t// ID, class, and element selectors\n\t\t\t\t\tre2 = quickClass;\n\t\t\t\t\tm = re2.exec(t);\n\t\t\t\t}\n\n\t\t\t\tm[2] = m[2].replace(/\\\\/g, \"\");\n\n\t\t\t\tvar elem = ret[ret.length-1];\n\n\t\t\t\t// Try to do a global search by ID, where we can\n\t\t\t\tif ( m[1] == \"#\" && elem && elem.getElementById && !jQuery.isXMLDoc(elem) ) {\n\t\t\t\t\t// Optimization for HTML document case\n\t\t\t\t\tvar oid = elem.getElementById(m[2]);\n\n\t\t\t\t\t// Do a quick check for the existence of the actual ID attribute\n\t\t\t\t\t// to avoid selecting by the name attribute in IE\n\t\t\t\t\t// also check to insure id is a string to avoid selecting an element with the name of 'id' inside a form\n\t\t\t\t\tif ( (jQuery.browser.msie||jQuery.browser.opera) && oid && typeof oid.id == \"string\" && oid.id != m[2] )\n\t\t\t\t\t\toid = jQuery('[@id=\"'+m[2]+'\"]', elem)[0];\n\n\t\t\t\t\t// Do a quick check for node name (where applicable) so\n\t\t\t\t\t// that div#foo searches will be really fast\n\t\t\t\t\tret = r = oid && (!m[3] || jQuery.nodeName(oid, m[3])) ? [oid] : [];\n\t\t\t\t} else {\n\t\t\t\t\t// We need to find all descendant elements\n\t\t\t\t\tfor ( var i = 0; ret[i]; i++ ) {\n\t\t\t\t\t\t// Grab the tag name being searched for"},{"path":"./jquery-data/1.2.4/src/selector.js","lines":[127,443],"code":"\t\t\t// Perform our own iteration and filter\n\t\t\tfor ( var i = 0; ret[i]; i++ )\n\t\t\t\tfor ( var c = ret[i].firstChild; c; c = c.nextSibling )\n\t\t\t\t\tif ( c.nodeType == 1 && (nodeName == \"*\" || c.nodeName.toUpperCase() == nodeName) )\n\t\t\t\t\t\tr.push( c );\n\n\t\t\tret = r;\n\t\t\tt = t.replace( re, \"\" );\n\t\t\tif ( t.indexOf(\" \") == 0 ) continue;\n\t\t\tfoundToken = true;\n\t\t} else {\n\t\t\tre = /^([>+~])\\s*(\\w*)/i;\n\n\t\t\tif ( (m = re.exec(t)) != null ) {\n\t\t\t\tr = [];\n\n\t\t\t\tvar merge = {};\n\t\t\t\tnodeName = m[2].toUpperCase();\n\t\t\t\tm = m[1];\n\n\t\t\t\tfor ( var j = 0, rl = ret.length; j < rl; j++ ) {\n\t\t\t\t\tvar n = m == \"~\" || m == \"+\" ? ret[j].nextSibling : ret[j].firstChild;\n\t\t\t\t\tfor ( ; n; n = n.nextSibling )\n\t\t\t\t\t\tif ( n.nodeType == 1 ) {\n\t\t\t\t\t\t\tvar id = jQuery.data(n);\n\n\t\t\t\t\t\t\tif ( m == \"~\" && merge[id] ) break;\n\n\t\t\t\t\t\t\tif (!nodeName || n.nodeName.toUpperCase() == nodeName ) {\n\t\t\t\t\t\t\t\tif ( m == \"~\" ) merge[id] = true;\n\t\t\t\t\t\t\t\tr.push( n );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( m == \"+\" ) break;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tret = r;\n\n\t\t\t\t// And remove the token\n\t\t\t\tt = jQuery.trim( t.replace( re, \"\" ) );\n\t\t\t\tfoundToken = true;\n\t\t\t}\n\t\t}\n\n\t\t// See if there's still an expression, and that we haven't already\n\t\t// matched a token\n\t\tif ( t && !foundToken ) {\n\t\t\t// Handle multiple expressions\n\t\t\tif ( !t.indexOf(\",\") ) {\n\t\t\t\t// Clean the result set\n\t\t\t\tif ( context == ret[0] ) ret.shift();\n\n\t\t\t\t// Merge the result sets\n\t\t\t\tdone = jQuery.merge( done, ret );\n\n\t\t\t\t// Reset the context\n\t\t\t\tr = ret = [context];\n\n\t\t\t\t// Touch up the selector string\n\t\t\t\tt = \" \" + t.substr(1,t.length);\n\n\t\t\t} else {\n\t\t\t\t// Optimize for the case nodeName#idName\n\t\t\t\tvar re2 = quickID;\n\t\t\t\tvar m = re2.exec(t);\n\n\t\t\t\t// Re-organize the results, so that they're consistent\n\t\t\t\tif ( m ) {\n\t\t\t\t\tm = [ 0, m[2], m[3], m[1] ];\n\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, do a traditional filter check for\n\t\t\t\t\t// ID, class, and element selectors\n\t\t\t\t\tre2 = quickClass;\n\t\t\t\t\tm = re2.exec(t);\n\t\t\t\t}\n\n\t\t\t\tm[2] = m[2].replace(/\\\\/g, \"\");\n\n\t\t\t\tvar elem = ret[ret.length-1];\n\n\t\t\t\t// Try to do a global search by ID, where we can\n\t\t\t\tif ( m[1] == \"#\" && elem && elem.getElementById && !jQuery.isXMLDoc(elem) ) {\n\t\t\t\t\t// Optimization for HTML document case\n\t\t\t\t\tvar oid = elem.getElementById(m[2]);\n\n\t\t\t\t\t// Do a quick check for the existence of the actual ID attribute\n\t\t\t\t\t// to avoid selecting by the name attribute in IE\n\t\t\t\t\t// also check to insure id is a string to avoid selecting an element with the name of 'id' inside a form\n\t\t\t\t\tif ( (jQuery.browser.msie||jQuery.browser.opera) && oid && typeof oid.id == \"string\" && oid.id != m[2] )\n\t\t\t\t\t\toid = jQuery('[@id=\"'+m[2]+'\"]', elem)[0];\n\n\t\t\t\t\t// Do a quick check for node name (where applicable) so\n\t\t\t\t\t// that div#foo searches will be really fast\n\t\t\t\t\tret = r = oid && (!m[3] || jQuery.nodeName(oid, m[3])) ? [oid] : [];\n\t\t\t\t} else {\n\t\t\t\t\t// We need to find all descendant elements\n\t\t\t\t\tfor ( var i = 0; ret[i]; i++ ) {\n\t\t\t\t\t\t// Grab the tag name being searched for"}]}]
